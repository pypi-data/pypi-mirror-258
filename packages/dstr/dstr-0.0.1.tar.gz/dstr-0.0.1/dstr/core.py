# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['NDim', 'Dims', 'Spec', 'Chars', 'Flag', 'DType', 'DimChars', 'DimType', 'dimchars', 'size2str', 'DimName', 'dstr',
           'sstr', 'tensiz', 'vidsiz', 'dimstr', 'vidstr', 'tenstr']

# %% ../nbs/00_core.ipynb 6
from enum import StrEnum, auto
from functools import singledispatch, wraps

# %% ../nbs/00_core.ipynb 8
from types import NoneType
from typing import (Type, Self, Union, Tuple, TypeAlias, Optional, ClassVar, overload, Callable)

# %% ../nbs/00_core.ipynb 10
#| export


# %% ../nbs/00_core.ipynb 12
from nchr import U1, NIL, MUL
from nlit import NAME
from atup import vargs

# %% ../nbs/00_core.ipynb 14
#| export


# %% ../nbs/00_core.ipynb 16
NDim: TypeAlias = int
'''An integer representing the number of dimensions of a multi-dimensional array''';

Dims: TypeAlias = tuple[int, ...]
'''A tuple of integers representing the dimensions of a multi-dimensional array''';

Spec: TypeAlias = Union[NDim, Dims]
'''Dimensions Specification i.e. A single integer or a 
tuple of integers representing the dimensions of a multi-dimensional array''';

Chars: TypeAlias = Optional[str]
'''A single string representing an ordered sequence of characters''';

Flag: TypeAlias = Optional[bool]
'''A boolean value representing a whether or not a flag is set''';

# %% ../nbs/00_core.ipynb 18
#| export


# %% ../nbs/00_core.ipynb 20
def makejoin(char: str) -> Callable[[tuple[str, ...], bool], str]:
    def joinstr(*strs, drop: bool = True) -> str:
        strs = tuple(map(str, tuple(vargs(strs)))) 
        strs = tuple(filter(lambda s: s, strs)) if drop else strs
        return char.join(strs)
    return joinstr

mulstr = makejoin(MUL)
sunstr = makejoin(U1)

# %% ../nbs/00_core.ipynb 23
class DimChars(StrEnum):
    '''
    Enumeration representing different dimensionality character labels for tensors.

    Members
    -------
    ij : General 2D tensor.
    hw : 2D spatial dimensions (height and width).
    xy : General 2D spatial dimensions.
    
    nhw : Batch of 2D spatial dimensions.
    hwd : Height-Width-Depth for 3D spatial dimensions.
    hwc : Height-Width-Channel for 3D image dimensions.
    ijk : General 3D tensor.
    xyz : General 3D spatial dimensions.
    
    ctp : Channel-Time-Polarization for multi-polarized time series data
    cst : Channel-Spatial-Temporal format, focusing on channels first followed by spatial and temporal dimensions
    dft : Dimension-Frequency-Time for frequency domain data across time
    lvh : Length-Volume-Height for 3D sequences with variable lengths and volumes
    rst : Row-Slice-Time for time series of 2D slices or images
    vct : Volume-Channel-Time for 3D medical imaging data across time
    
    ijkl : General 4D tensor.
    nchw : Tensor in NCHW format.
    nhwc : Tensor in NHWC format.
    thwc : Video in Time-Height-Width-Channel format.

    Examples
    --------
    >>> DimChars.ijk
    DimChars.ijk

    >>> DimChars.nchw.name
    'nchw'
    '''
    ij   = auto()
    '''General 2D tensor''';
    
    hw   = auto()
    '''2D spatial dimensions (height and width)''';
    
    xy   = auto()
    '''General 2D tensor''';
    
    tf   = auto()
    '''2D temporal tensor (time, features)''';
    
    cst  = auto()
    '''Channel-Spatial-Temporal format, focusing on channels first followed by spatial and temporal dimensions.''';
    
    ctp  = auto()
    '''Channel-Time-Polarization for multi-polarized time series data''';
    
    dft  = auto()
    '''Dimension-Frequency-Time for frequency domain data across time''';
    
    ijk  = auto()
    '''General 3D tensor''';
    
    hwd  = auto()
    '''Height-Width-Depth for 3D spatial dimensions''';
    
    hwc  = auto()
    '''Height-Width-Channel for 3D image dimensions''';
    
    lvh  = auto()
    '''Length-Volume-Height for 3D sequences with variable lengths and volumes.''';
    
    nhw  = auto()
    '''Batch of 2D spatial dimensions''';
    
    rst  = auto()
    '''Row-Slice-Time for time series of 2D slices or images''';
    
    vct  = auto()
    '''Volume-Channel-Time for 3D medical imaging data across time''';
    
    xyz  = auto()
    '''General 3D spatial dimensions''';
    
    ijkl  = auto()
    '''General 4D tensor''';
    
    nchw = auto()
    '''Tensor in NCHW format''';
    
    nhwc = auto()
    '''Tensor in NHWC format''';
    
    thwc = auto()
    '''Video in Time-Height-Width-Channel format''';

# %% ../nbs/00_core.ipynb 25
class DimType(StrEnum):
    '''
    Enumeration representing different types of data represented by tensors.

    Members
    -------
    ten : General tensor.
    arr : Array-like tensor.
    vid : Video data tensor.
    img : Image data tensor.
    mat : General matrix.
    seq : Sequence tensor.
    nlp : Natural Language Processing data.

    Examples
    --------
    >>> DimType.ten
    DimType.ten

    >>> DimType.img.name
    'img'
    '''
    
    ten = auto()
    '''General tensor''';
    
    arr = auto()
    '''Array-like data''';
    
    vid = auto()
    '''Video data tensor''';
    
    img = auto()
    '''Image-data tensor''';
    
    mat = auto()
    '''General matrix''';
    
    seq = auto()
    '''Sequence tensor''';
    
    nlp = auto()
    '''Natural Language Processing data''';
    
DType: TypeAlias = Optional[DimType]
'''A string or enumeration member's value (e.g. `DimType`) 
representing the type of data within a tensor e.g. `DimType.vid`''';

# %% ../nbs/00_core.ipynb 27
@singledispatch
def _dimchars(ndim: NDim, dtype: DimType = DimType.ten, default: Chars = NIL) -> str:
    match (dtype, ndim):
        case (DimType.ten, 2): return str(DimChars.ij)
        case (DimType.ten, 3): return str(DimChars.ijk)
        case (DimType.ten, 4): return str(DimChars.ijkl)
        
        case (DimType.arr, 2): return str(DimChars.xy)
        case (DimType.arr, 3): return str(DimChars.xyz)
        
        case (DimType.img, 2): return str(DimChars.hw)
        case (DimType.img, 3): return str(DimChars.hwc)
        
        case (DimType.vid, 2): return str(DimChars.tf)
        case (DimType.vid, 3): return str(DimChars.nhw)
        case (DimType.vid, 4): return str(DimChars.thwc)
        
        case (None, _): return str(default) or NIL
        case (_, 2): return str(DimChars.ij)
        case (_, 3): return str(DimChars.ijk)
        case (_, 4): return str(dtype) if dtype else str(default)
        case (default, _): return str(default)
        case (dtype, _): return str(dtype) if dtype else str(default)
        case _: return default or NIL

@_dimchars.register(tuple)
@_dimchars.register(list)
def _(dims: Dims, dtype: DType = DimType.ten, default: Chars = NIL) -> str:
    ndim = len(dims)
    chars = _dimchars(ndim, dtype, default)
    return getattr(chars, NAME, chars) if chars else default

# %% ../nbs/00_core.ipynb 28
@overload
def dimchars(dims: Dims, dtype: DType = DimType.ten, default: Chars = NIL) -> str: ...
@overload
def dimchars(ndim: NDim, dtype: DType = DimType.ten, default: Chars = NIL) -> str: ...
def dimchars(spec: Spec, dtype: DType = DimType.ten, default: Chars = NIL):
    '''Returns a string representing the dimension characters for the given dimensions.

    Parameters
    ----------
    spec : int | tuple[int, ...]
        Either the number of dimensions or a tuple representing the dimensions of the tensor.
    
    dtype : DimType, optional
        The type of the tensor to provide context for dimension characters, defaults to DimType.ten.
    
    default : str, optional
        The default value to return if no match is found, defaults to an empty string.
        
    Returns
    -------
    str
        A string representing the dimension characters, or an empty string if no match is found.

    Examples
    --------
    >>> dimchars((3, 3, 3), DimType.ten)
    'ijk'

    >>> dimchars((1, 28, 28, 3), DimType.vid)
    'thwc'
    
    See Also
    --------
    DimName.get
    
    Notes
    -----
    - case `(DimType.ten, 3)` ==> `DimChars.ijk`
    - case `(DimType.arr, 3)` ==> `DimChars.xyz`
    - case `(DimType.vid, 4)` ==> `DimChars.thwc`
    - case `(DimType.vid, 3)` ==> `DimChars.hw`
    - case `(DimType.img, 2)` ==> `DimChars.hw`
    - case `(DimType.img, 3)` ==> `DimChars.nhw`
    '''
    return _dimchars(spec, dtype, default)

# %% ../nbs/00_core.ipynb 31
@singledispatch
def _size2str(spec: Optional[Spec], dtype: DimType = DimType.ten, times: bool = False, default: Chars = NIL) -> str:
    return default

@_size2str.register(NoneType)
def _(spec: None, dtype: DimType = DimType.ten, times: bool = False, default: Chars = NIL) -> str:
    # print('_size2str, NoneType')
    return NIL

@_size2str.register(list)
@_size2str.register(tuple)
def _(spec: Dims, dtype: DType = DimType.ten, times: bool = False, default: Chars = NIL) -> str:
    # print('_size2str, list/tuple')
    dims = dimchars(spec, dtype, default) # e.g. 'ijk'
    nums = mulstr(*spec) if times else sunstr(*spec) # e.g. '3x3x3'
    # print(spec, times, dims, nums)
    if dims != NIL: return f'{dims}{U1}{nums}'
    return nums


@_size2str.register(int)
def _(spec: NDim, dtype: DimType = DimType.ten, times: bool = False, default: Chars = NIL) -> str:
    # print('_size2str, int')
    spec = tuple(f'd{i}' for i in range(1, spec + 1))
    return _size2str.registry[tuple](spec, dtype, times, default)

# %% ../nbs/00_core.ipynb 32
@overload
def size2str(none: NoneType, dtype: DType = DimType.ten, times: bool = False, default: Chars = NIL) -> str: ...
@overload
def size2str(ndim: NDim, dtype: DType = DimType.ten, times: bool = False, default: Chars = NIL) -> str: ...
@overload
def size2str(dims: Dims, dtype: DType = DimType.ten, times: bool = False, default: Chars = NIL) -> str: ...
@overload
def size2str(spec: Spec, dtype: DType = DimType.ten, times: bool = False, default: Chars = NIL) -> str: ...
def size2str(
    size: Optional[Spec],
    dtype: DType = DimType.img,
    times: bool = False,
    default: Chars = NIL
) -> str:
    '''Converts a size tuple to a string representation, optionally including dimension characters.

    Parameters
    ----------
    spec : int | tuple[int, ...]
        Either the number of dimensions or a tuple representing the dimensions of the tensor.
        
    dtype : DimType, default: DimType.img
        The type of the tensor for context in representation, defaults to DimType.img.
        
    times : bool, default: False
        If True, uses a 'x' character to join dimensions, defaults to False.
        
    default : str, optional
        The default value to return if no match is found, defaults to an empty string.

    Returns
    -------
    str
        The string representation of the size.
    '''
    return _size2str(size, dtype, times, default)

# %% ../nbs/00_core.ipynb 36
class DimName:
    '''Enumeration representing different types of data represented by tensors.
    
    Methods
    -------
    get(dims: tuple[int, ...], dtype: DimType, default: Optional[str] = NIL) -> str
        Gets the dimension name for the specified data type and number of dimensions.
        
    dimchars(dims: int | tuple[int, ...], dtype: DimType = DimType.ten, default: Optional[str] = NIL) -> str
        Returns a string representing the dimension characters for the given dimensions.
        
    size2str(size: Optional[tuple[int, ...]], dtype: DimType = DimType.img, use_cross: bool = False) -> str
        Converts a size tuple to a string representation, optionally including dimension characters.
    
    Notes
    -----
    - case `(DimType.ten, 3)` ==> `DimChars.ijk`
    - case `(DimType.arr, 3)` ==> `DimChars.xyz`
    - case `(DimType.vid, 4)` ==> `DimChars.thwc`
    - case `(DimType.vid, 3)` ==> `DimChars.hw`
    - case `(DimType.img, 2)` ==> `DimChars.hw`
    - case `(DimType.img, 3)` ==> `DimChars.nhw`
    '''
    @overload
    def get(cls, dims: Dims, dtype: DType, default: Chars = NIL) -> str: ...
    @overload
    def get(cls, ndim: NDim, dtype: DType, default: Chars = NIL) -> str: ...
    @classmethod
    def get(cls, spec: Spec, dtype: DType, default: Chars = NIL) -> str:
        '''
        Gets the dimension name for the specified data type and number of dimensions.

        Notes
        -----
        - case `(DimType.ten, 3)` ==> `DimChars.ijk`
        - case `(DimType.arr, 3)` ==> `DimChars.xyz`
        - case `(DimType.vid, 4)` ==> `DimChars.thwc`
        - case `(DimType.vid, 3)` ==> `DimChars.hw`
        - case `(DimType.img, 2)` ==> `DimChars.hw`
        - case `(DimType.img, 3)` ==> `DimChars.nhw`
        '''
        return dimchars(spec, dtype, default)
    
    dimchars = dimchars
    size2str = size2str

# %% ../nbs/00_core.ipynb 41
class basemeta(type):
    chars: ClassVar[DimChars] = DimChars.ijk
    '''The character labels for the dimensions of the tensor as a single string e.g. `'ijk'`.''';
    
    dtype: ClassVar[DimType] = DimType.ten
    '''The type of data represented by the tensor.''';
    
    times: ClassVar[bool] = False
    '''A boolean indicating whether to use the multiplication operator character `'x'` to join dimensions.''';
    
    types: tuple[DimType, ...] = tuple(DimType)
    '''A tuple of all the enumeration members of DimType''';
    
    reprs: tuple[DimChars, ...] = tuple(DimChars)
    '''A tuple of all the enumeration members of DimChars''';
    
    aspec: tuple[tuple[str, tuple[type, ...]], ...] = (
        ('dtype', (type, str, DimType)), 
        ('chars', (type, str, DimChars)), 
        ('times', (bool, )),
    )
    '''A tuple of tuples representing the expected keyword arguments for the class constructor''';
    
    deco: bool = False
    '''A boolean indicating whether the class has been decorated with the `@new` decorator''';
    
    scls: bool = False
    '''A boolean indicating whether the class has been subclassed''';

    def docs(cls: Type[Self], chars: DimChars = DimChars.ijk) -> str:
        return f'''Create a string representing the dimensions of a tensor as str i.e. `{chars}{U1}d1{MUL}d2{MUL}d3'''
    
    def new(
        cls: Type[Self], 
        dtype: DimType = DimType.ten,
        chars: DimChars = DimChars.ijk,
        *args,
        times: bool = False,
        deco: bool = False,
        scls: bool = False,
        **kwargs
    ) -> Type[Self]:
        @wraps(cls.__class__)
        def decorator(kls: type) -> Type[Self]:
            dct = dict(chars = chars, dtype = dtype, times = times, __doc__ = cls.docs(chars), deco = deco, scls = scls)
            new = cls.__class__(kls.__name__, (cls, ), dct, **kwargs)
            new._deco = True
            return new
        return decorator
    
    @overload
    def make(cls: Type[Self], dims: Dims, dtype: DType = None, default: Chars = NIL) -> str: ...
    @overload
    def make(cls: Type[Self], ndim: NDim, dtype: DType = None, default: Chars = NIL) -> str: ...
    def make(cls: Type[Self], spec: Spec, dtype: DType = None, default: Chars = NIL) -> str:
        return dimchars(spec, dtype or cls.dtype, default or cls.chars)
        
    def __call__(cls: Type[Self], *args, **kwargs) -> Union[Type[Self], str]:
        # print(f'args: {args}, kwargs: {kwargs}')
        good = len(args) == 1 and (isinstance(args[0], (int, tuple)) or len(args) > len(cls.aspec))
        deco = getattr(cls, 'deco', False)
        
        # if deco: return cls.make(*args, **kwargs)
        # if good and deco: return cls.make(*args, **kwargs)
        if good and deco: return cls.new(*args, **kwargs)
        
        make = False
        iadj = 0
        kwds = set({kw for kw, _ in cls.aspec if kw in kwargs})
        for i, arg in enumerate(args):
            kw, ts = cls.aspec[i]
            if kw in kwds: 
                iadj += 1
                continue
            
            # keyword not present and arg is not of the right type, 
            j = i - iadj
            badj = (j < 0 or len(cls.aspec) <= j)
            if not isinstance(arg, ts) or (not badj and not isinstance(arg, cls.aspec[j][1])):
                make = True
                break
        
        # print(f'__call__, not make: {not make}')
        if not make: return cls.new(*args, **kwargs)
        return cls.make(*args, **kwargs)


# %% ../nbs/00_core.ipynb 42
class dimsmeta(basemeta): ...

class sizemeta(basemeta):
    @overload
    def make(cls: Self, dims: Dims, dtype: DType = None, times: Flag = False, default: Chars = NIL) -> str: ...
    @overload
    def make(cls: Self, ndim: NDim, dtype: DType = None, times: Flag = False, default: Chars = NIL) -> str: ...
    def make(cls: Self, spec: Spec, dtype: DType = None, times: Flag = False, default: Chars = NIL) -> str:
        # print('sizemeta', spec, dtype or cls.dtype or cls.chars, times or cls.times, default or cls.chars)
        return size2str(spec, dtype or cls.dtype or cls.chars, times or cls.times, default or cls.chars)

# %% ../nbs/00_core.ipynb 43
class dstr(metaclass=dimsmeta):
    '''Dimmensional String Representation
    
    Examples
    --------
    >>> dstr(3), dstr(4), dstr(2, DimType.img)
    ('ijk', 'ijkl', 'hw')
    
    >>> @dstr(DimType.vid, DimChars.thwc)
    ... class vidstr: ...
    ...
    ... @dstr(DimType.ten, DimChars.ijk)
    ... class tenstr: ...
    ... (
    ...     (vidstr(1), vidstr(2), vidstr(3), vidstr(4),),
    ...     (tenstr(1), tenstr(2), tenstr(3), tenstr(4),)
    ... )
    (('vid', 'vid', 'nhw', 'thwc'), ('ten', 'ij', 'ijk', 'ijkl'))
    '''
    @overload
    def __init__(self: Self, dims: Dims, dtype: DType = None, default: Chars = NIL) -> str: ...
    @overload
    def __init__(self: Self, ndim: NDim, dtype: DType = None, default: Chars = NIL) -> str: ...
    @overload
    def __init__(self: Self, spec: Spec, dtype: DType = None, default: Chars = NIL) -> str: ...
    @overload
    def __init__(self: Self, *args, **kwargs) -> Tuple[Type[Self], str]: ...
    def __init__(spec: Spec, dtype: DType = None, default: Chars = NIL) -> Tuple[Type[Self], str]:
        '''Returns a string representing the dimension characters for the given dimensions.

        Parameters
        ----------
        spec : int | tuple[int, ...]
            Either the number of dimensions or a tuple representing the dimensions of the tensor.
        
        dtype : DimType, optional
            The type of the tensor to provide context for dimension characters, defaults to DimType.ten.
        
        default : str, optional
            The default value to return if no match is found, defaults to an empty string.
            
        Returns
        -------
        str
            A string representing the dimension characters, or an empty string if no match is found.
        '''
        return super().__call__(spec, dtype, default)

    
    
class sstr(metaclass=sizemeta):
    '''Size String Representation
    
    Examples
    --------
    >>> sstr(3), sstr(4), sstr(2, DimType.img), sstr(2, DimType.img, True)
    ('ijk_d1_d2_d3', 'ijkl_d1_d2_d3_d4', 'hw_d1_d2', 'hw_d1xd2')
    
    >>> @dstr(DimType.vid, DimChars.thwc)
    ... class vidstr: ...
    ...
    ... @dstr(DimType.ten, DimChars.ijk)
    ... class tenstr: ...
    ... (
    ...     (vidstr(1), vidstr(2), vidstr(3), vidstr(4),),
    ...     (tenstr(1), tenstr(2), tenstr(3), tenstr(4),)
    ... )
    (('vid', 'vid', 'nhw', 'thwc'), ('ten', 'ij', 'ijk', 'ijkl'))
    '''

# %% ../nbs/00_core.ipynb 44
@sstr(DimType.ten, times=True)
class tensiz: ...

@sstr(DimType.vid, DimChars.thwc, times=True)
class vidsiz: ...

# %% ../nbs/00_core.ipynb 47
@wraps(dstr, updated=())
class dimstr(dstr): 
    ...

@dstr(DimType.vid, DimChars.thwc)
class vidstr: ...


@dstr(DimType.ten, DimChars.ijk)
class tenstr: ...

# %% ../nbs/00_core.ipynb 52
#| export
