# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_size.ipynb.

# %% auto 0
__all__ = ['size2str', 'DimName', 'dstr', 'sstr', 'tensiz', 'vidsiz', 'dimstr', 'vidstr', 'tenstr']

# %% ../nbs/04_size.ipynb 6
from functools import singledispatch, wraps

# %% ../nbs/04_size.ipynb 8
from types import NoneType
from typing import (Type, Self, Union, Tuple, Optional, ClassVar, overload)

# %% ../nbs/04_size.ipynb 10
#| export


# %% ../nbs/04_size.ipynb 12
from nchr import U1, NIL, MUL

# %% ../nbs/04_size.ipynb 14
from .enum import DimChars, DimType
from .type import NDim, Dims, Spec, Chars, Flag, DType
from .util import mulstr, sunstr
from .char import dimchars

# %% ../nbs/04_size.ipynb 17
@singledispatch
def _size2str(spec: Optional[Spec], dtype: DimType = DimType.ten, times: bool = False, default: Chars = NIL) -> str:
    return default

@_size2str.register(NoneType)
def _(spec: None, dtype: DimType = DimType.ten, times: bool = False, default: Chars = NIL) -> str:
    return NIL

@_size2str.register(list)
@_size2str.register(tuple)
def _(spec: Dims, dtype: DType = DimType.ten, times: bool = False, default: Chars = NIL) -> str:
    dims = dimchars(spec, dtype, default) # e.g. 'ijk'
    nums = mulstr(*spec) if times else sunstr(*spec) # e.g. '3x3x3'
    if dims != NIL: return f'{dims}{U1}{nums}'
    return nums

@_size2str.register(int)
def _(spec: NDim, dtype: DimType = DimType.ten, times: bool = False, default: Chars = NIL) -> str:
    spec = tuple(f'd{i}' for i in range(1, spec + 1))
    return _size2str.registry[tuple](spec, dtype, times, default)

# %% ../nbs/04_size.ipynb 19
@overload
def size2str(none: NoneType, dtype: DType = DimType.ten, times: bool = False, default: Chars = NIL) -> str: ...
@overload
def size2str(ndim: NDim, dtype: DType = DimType.ten, times: bool = False, default: Chars = NIL) -> str: ...
@overload
def size2str(dims: Dims, dtype: DType = DimType.ten, times: bool = False, default: Chars = NIL) -> str: ...
@overload
def size2str(spec: Spec, dtype: DType = DimType.ten, times: bool = False, default: Chars = NIL) -> str: ...
def size2str(
    size: Optional[Spec],
    dtype: DType = DimType.img,
    times: bool = False,
    default: Chars = NIL
) -> str:
    '''Converts a size tuple to a string representation, optionally including dimension characters.

    Parameters
    ----------
    spec : int | tuple[int, ...]
        Either the number of dimensions or a tuple representing the dimensions of the tensor.
        
    dtype : DimType, default: DimType.img
        The type of the tensor for context in representation, defaults to DimType.img.
        
    times : bool, default: False
        If True, uses a 'x' character to join dimensions, defaults to False.
        
    default : str, optional
        The default value to return if no match is found, defaults to an empty string.

    Returns
    -------
    str
        The string representation of the size.
    '''
    return _size2str(size, dtype, times, default)

# %% ../nbs/04_size.ipynb 23
class DimName:
    '''Enumeration representing different types of data represented by tensors.
    
    Methods
    -------
    get(dims: tuple[int, ...], dtype: DimType, default: Optional[str] = NIL) -> str
        Gets the dimension name for the specified data type and number of dimensions.
        
    dimchars(dims: int | tuple[int, ...], dtype: DimType = DimType.ten, default: Optional[str] = NIL) -> str
        Returns a string representing the dimension characters for the given dimensions.
        
    size2str(size: Optional[tuple[int, ...]], dtype: DimType = DimType.img, use_cross: bool = False) -> str
        Converts a size tuple to a string representation, optionally including dimension characters.
    
    Notes
    -----
    - case `(DimType.ten, 3)` ==> `DimChars.ijk`
    - case `(DimType.arr, 3)` ==> `DimChars.xyz`
    - case `(DimType.vid, 4)` ==> `DimChars.thwc`
    - case `(DimType.vid, 3)` ==> `DimChars.hw`
    - case `(DimType.img, 2)` ==> `DimChars.hw`
    - case `(DimType.img, 3)` ==> `DimChars.nhw`
    '''
    @overload
    def get(cls, dims: Dims, dtype: DType, default: Chars = NIL) -> str: ...
    @overload
    def get(cls, ndim: NDim, dtype: DType, default: Chars = NIL) -> str: ...
    @classmethod
    def get(cls, spec: Spec, dtype: DType, default: Chars = NIL) -> str:
        '''
        Gets the dimension name for the specified data type and number of dimensions.

        Notes
        -----
        - case `(DimType.ten, 3)` ==> `DimChars.ijk`
        - case `(DimType.arr, 3)` ==> `DimChars.xyz`
        - case `(DimType.vid, 4)` ==> `DimChars.thwc`
        - case `(DimType.vid, 3)` ==> `DimChars.hw`
        - case `(DimType.img, 2)` ==> `DimChars.hw`
        - case `(DimType.img, 3)` ==> `DimChars.nhw`
        '''
        return dimchars(spec, dtype, default)
    
    dimchars = dimchars
    size2str = size2str

# %% ../nbs/04_size.ipynb 28
class basemeta(type):
    chars: ClassVar[DimChars] = DimChars.ijk
    '''The character labels for the dimensions of the tensor as a single string e.g. `'ijk'`.''';
    
    dtype: ClassVar[DimType] = DimType.ten
    '''The type of data represented by the tensor.''';
    
    times: ClassVar[bool] = False
    '''A boolean indicating whether to use the multiplication operator character `'x'` to join dimensions.''';
    
    types: tuple[DimType, ...] = tuple(DimType)
    '''A tuple of all the enumeration members of DimType''';
    
    reprs: tuple[DimChars, ...] = tuple(DimChars)
    '''A tuple of all the enumeration members of DimChars''';
    
    aspec: tuple[tuple[str, tuple[type, ...]], ...] = (
        ('dtype', (type, str, DimType)), 
        ('chars', (type, str, DimChars)), 
        ('times', (bool, )),
    )
    '''A tuple of tuples representing the expected keyword arguments for the class constructor''';
    
    deco: bool = False
    '''A boolean indicating whether the class has been decorated with the `@new` decorator''';
    
    scls: bool = False
    '''A boolean indicating whether the class has been subclassed''';

    def docs(cls: Type[Self], chars: DimChars = DimChars.ijk) -> str:
        return f'''Create a string representing the dimensions of a tensor as str i.e. `{chars}{U1}d1{MUL}d2{MUL}d3'''
    
    def new(
        cls: Type[Self], 
        dtype: DimType = DimType.ten,
        chars: DimChars = DimChars.ijk,
        *args,
        times: bool = False,
        deco: bool = False,
        scls: bool = False,
        **kwargs
    ) -> Type[Self]:
        @wraps(cls.__class__)
        def decorator(kls: type) -> Type[Self]:
            dct = dict(chars = chars, dtype = dtype, times = times, __doc__ = cls.docs(chars), deco = deco, scls = scls)
            new = cls.__class__(kls.__name__, (cls, ), dct, **kwargs)
            new._deco = True
            return new
        return decorator
    
    @overload
    def make(cls: Type[Self], dims: Dims, dtype: DType = None, default: Chars = NIL) -> str: ...
    @overload
    def make(cls: Type[Self], ndim: NDim, dtype: DType = None, default: Chars = NIL) -> str: ...
    def make(cls: Type[Self], spec: Spec, dtype: DType = None, default: Chars = NIL) -> str:
        return dimchars(spec, dtype or cls.dtype, default or cls.chars)
        
    def __call__(cls: Type[Self], *args, **kwargs) -> Union[Type[Self], str]:
        # print(f'args: {args}, kwargs: {kwargs}')
        good = len(args) == 1 and (isinstance(args[0], (int, tuple)) or len(args) > len(cls.aspec))
        deco = getattr(cls, 'deco', False)
        
        # if deco: return cls.make(*args, **kwargs)
        # if good and deco: return cls.make(*args, **kwargs)
        if good and deco: return cls.new(*args, **kwargs)
        
        make = False
        iadj = 0
        kwds = set({kw for kw, _ in cls.aspec if kw in kwargs})
        for i, arg in enumerate(args):
            kw, ts = cls.aspec[i]
            if kw in kwds: 
                iadj += 1
                continue
            
            # keyword not present and arg is not of the right type, 
            j = i - iadj
            badj = (j < 0 or len(cls.aspec) <= j)
            if not isinstance(arg, ts) or (not badj and not isinstance(arg, cls.aspec[j][1])):
                make = True
                break
        
        # print(f'__call__, not make: {not make}')
        if not make: return cls.new(*args, **kwargs)
        return cls.make(*args, **kwargs)


# %% ../nbs/04_size.ipynb 29
class dimsmeta(basemeta): ...

class sizemeta(basemeta):
    @overload
    def make(cls: Self, dims: Dims, dtype: DType = None, times: Flag = False, default: Chars = NIL) -> str: ...
    @overload
    def make(cls: Self, ndim: NDim, dtype: DType = None, times: Flag = False, default: Chars = NIL) -> str: ...
    def make(cls: Self, spec: Spec, dtype: DType = None, times: Flag = False, default: Chars = NIL) -> str:
        # print('sizemeta', spec, dtype or cls.dtype or cls.chars, times or cls.times, default or cls.chars)
        return size2str(spec, dtype or cls.dtype or cls.chars, times or cls.times, default or cls.chars)

# %% ../nbs/04_size.ipynb 30
class dstr(metaclass=dimsmeta):
    '''Dimmensional String Representation
    
    Examples
    --------
    >>> dstr(3), dstr(4), dstr(2, DimType.img)
    ('ijk', 'ijkl', 'hw')
    
    >>> @dstr(DimType.vid, DimChars.thwc)
    ... class vidstr: ...
    ...
    ... @dstr(DimType.ten, DimChars.ijk)
    ... class tenstr: ...
    ... (
    ...     (vidstr(1), vidstr(2), vidstr(3), vidstr(4),),
    ...     (tenstr(1), tenstr(2), tenstr(3), tenstr(4),)
    ... )
    (('vid', 'vid', 'nhw', 'thwc'), ('ten', 'ij', 'ijk', 'ijkl'))
    '''
    @overload
    def __init__(self: Self, dims: Dims, dtype: DType = None, default: Chars = NIL) -> str: ...
    @overload
    def __init__(self: Self, ndim: NDim, dtype: DType = None, default: Chars = NIL) -> str: ...
    @overload
    def __init__(self: Self, spec: Spec, dtype: DType = None, default: Chars = NIL) -> str: ...
    @overload
    def __init__(self: Self, *args, **kwargs) -> Tuple[Type[Self], str]: ...
    def __init__(spec: Spec, dtype: DType = None, default: Chars = NIL) -> Tuple[Type[Self], str]:
        '''Returns a string representing the dimension characters for the given dimensions.

        Parameters
        ----------
        spec : int | tuple[int, ...]
            Either the number of dimensions or a tuple representing the dimensions of the tensor.
        
        dtype : DimType, optional
            The type of the tensor to provide context for dimension characters, defaults to DimType.ten.
        
        default : str, optional
            The default value to return if no match is found, defaults to an empty string.
            
        Returns
        -------
        str
            A string representing the dimension characters, or an empty string if no match is found.
        '''
        return super().__call__(spec, dtype, default)

    
    
class sstr(metaclass=sizemeta):
    '''Size String Representation
    
    Examples
    --------
    >>> sstr(3), sstr(4), sstr(2, DimType.img), sstr(2, DimType.img, True)
    ('ijk_d1_d2_d3', 'ijkl_d1_d2_d3_d4', 'hw_d1_d2', 'hw_d1xd2')
    
    >>> @dstr(DimType.vid, DimChars.thwc)
    ... class vidstr: ...
    ...
    ... @dstr(DimType.ten, DimChars.ijk)
    ... class tenstr: ...
    ... (
    ...     (vidstr(1), vidstr(2), vidstr(3), vidstr(4),),
    ...     (tenstr(1), tenstr(2), tenstr(3), tenstr(4),)
    ... )
    (('vid', 'vid', 'nhw', 'thwc'), ('ten', 'ij', 'ijk', 'ijkl'))
    '''

# %% ../nbs/04_size.ipynb 31
@sstr(DimType.ten, times=True)
class tensiz: ...

@sstr(DimType.vid, DimChars.thwc, times=True)
class vidsiz: ...

# %% ../nbs/04_size.ipynb 34
@wraps(dstr, updated=())
class dimstr(dstr): 
    ...

@dstr(DimType.vid, DimChars.thwc)
class vidstr: ...


@dstr(DimType.ten, DimChars.ijk)
class tenstr: ...

# %% ../nbs/04_size.ipynb 39
#| export
