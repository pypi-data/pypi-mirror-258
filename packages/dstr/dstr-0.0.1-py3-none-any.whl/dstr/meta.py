# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_meta.ipynb.

# %% auto 0
__all__ = []

# %% ../nbs/06_meta.ipynb 6
from functools import wraps

# %% ../nbs/06_meta.ipynb 8
from typing import (Type, Self, Union, ClassVar, overload, )

# %% ../nbs/06_meta.ipynb 10
#| export


# %% ../nbs/06_meta.ipynb 12
from nchr import U1, NIL, MUL


# %% ../nbs/06_meta.ipynb 14
from .enum import DimChars, DimType
from .type import NDim, Dims, Spec, Chars, Flag, DType, VarSpecs
from .char import dimchars
from .size import size2str

# %% ../nbs/06_meta.ipynb 16
class basemeta(type):
    chars: ClassVar[DimChars] = DimChars.ijk
    '''The character labels for the dimensions of the tensor as a single string e.g. `'ijk'`.''';
    
    dtype: ClassVar[DimType] = DimType.ten
    '''The type of data represented by the tensor.''';
    
    times: ClassVar[bool] = False
    '''A boolean indicating whether to use the multiplication operator character `'x'` to join dimensions.''';
    
    types: tuple[DimType, ...] = tuple(DimType)
    '''A tuple of all the enumeration members of DimType''';
    
    reprs: tuple[DimChars, ...] = tuple(DimChars)
    '''A tuple of all the enumeration members of DimChars''';
    
    aspec: VarSpecs = (
        ('dtype', (type, str, DimType)), 
        ('chars', (type, str, DimChars)), 
        ('times', (bool, )),
    )
    '''A tuple of tuples representing the expected keyword arguments for the class constructor''';
    
    deco: bool = False
    '''A boolean indicating whether the class has been decorated with the `@new` decorator''';
    
    scls: bool = False
    '''A boolean indicating whether the class has been subclassed''';

    def docs(cls: Type[Self], chars: DimChars = DimChars.ijk) -> str:
        return f'''Create a string representing the dimensions of a tensor as str i.e. `{chars}{U1}d1{MUL}d2{MUL}d3'''
    
    def new(
        cls: Type[Self], 
        dtype: DimType = DimType.ten,
        chars: DimChars = DimChars.ijk,
        *args,
        times: bool = False,
        deco: bool = False,
        scls: bool = False,
        **kwargs
    ) -> Type[Self]:
        @wraps(cls.__class__)
        def decorator(kls: type) -> Type[Self]:
            dct = dict(chars = chars, dtype = dtype, times = times, __doc__ = cls.docs(chars), deco = deco, scls = scls)
            new = cls.__class__(kls.__name__, (cls, ), dct, **kwargs)
            new.deco = True
            return new
        return decorator
    
    @overload
    def make(cls: Type[Self], dims: Dims, dtype: DType = None, default: Chars = NIL) -> str: ...
    @overload
    def make(cls: Type[Self], ndim: NDim, dtype: DType = None, default: Chars = NIL) -> str: ...
    def make(cls: Type[Self], spec: Spec, dtype: DType = None, default: Chars = NIL) -> str:
        return dimchars(spec, dtype or cls.dtype, default or cls.chars)
        
    def __call__(cls: Type[Self], *args, **kwargs) -> Union[Type[Self], str]:
        good = len(args) == 1 and (isinstance(args[0], (int, tuple)) or len(args) > len(cls.aspec))
        deco = getattr(cls, 'deco', False)
        
        if good and deco: return cls.new(*args, **kwargs)
        
        make = False
        iadj = 0
        kwds = set({kw for kw, _ in cls.aspec if kw in kwargs})
        for i, arg in enumerate(args):
            kw, ts = cls.aspec[i]
            if kw in kwds: 
                iadj += 1
                continue
            
            j = i - iadj
            badj = (j < 0 or len(cls.aspec) <= j)
            if not isinstance(arg, ts) or (not badj and not isinstance(arg, cls.aspec[j][1])):
                make = True
                break
        
        if not make: return cls.new(*args, **kwargs)
        return cls.make(*args, **kwargs)


# %% ../nbs/06_meta.ipynb 17
class dimsmeta(basemeta): ...

class sizemeta(basemeta):
    @overload
    def make(cls: Self, dims: Dims, dtype: DType = None, times: Flag = False, default: Chars = NIL) -> str: ...
    @overload
    def make(cls: Self, ndim: NDim, dtype: DType = None, times: Flag = False, default: Chars = NIL) -> str: ...
    def make(cls: Self, spec: Spec, dtype: DType = None, times: Flag = False, default: Chars = NIL) -> str:
        # print('sizemeta', spec, dtype or cls.dtype or cls.chars, times or cls.times, default or cls.chars)
        return size2str(spec, dtype or cls.dtype or cls.chars, times or cls.times, default or cls.chars)

# %% ../nbs/06_meta.ipynb 19
#| export
