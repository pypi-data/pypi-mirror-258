/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/python-kernel/python-executor.js":
/*!**********************************************!*\
  !*** ./src/python-kernel/python-executor.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   currentId: () => (/* binding */ currentId)\n/* harmony export */ });\nconst currentId = {\r\n  get: () => window._pyodide_component_currentId,\r\n  set: (value) => { window._pyodide_component_currentId = value; }\r\n};\r\n\r\nclass PythonExecutor {\r\n    constructor(strategy) {\r\n        this.strategy = strategy;\r\n        this.observers = [];\r\n        this.packages = [];\r\n        this.databaseInitQuery = [];\r\n        this.strategy.setStatusCallback((status) => this.notify(status));\r\n    }\r\n\r\n    async execute(code) {\r\n        await this.strategy.execute(code);\r\n    }\r\n\r\n    executeSQL(queryWrapper) {\r\n        this.strategy.executeSQL(queryWrapper);\r\n    }\r\n\r\n    interrupt(){\r\n        this.strategy.interrupt();\r\n    }\r\n\r\n    addPackages(packages) {\r\n        packages.forEach(p =>  {\r\n            if(!this.packages.includes(p)) \r\n                this.packages.push(p)\r\n        });\r\n    }\r\n\r\n    addDataBaseInitQuery(dbInitQuery) {\r\n        if(!this.databaseInitQuery.map(db => db['name']).includes(dbInitQuery['name']))\r\n            this.databaseInitQuery.push(dbInitQuery);\r\n    }\r\n\r\n    async initiate() {\r\n        this.strategy.setPackages(this.packages);\r\n        this.strategy.setDatabaseInitQuery(this.databaseInitQuery);\r\n        await this.strategy.installPackages();\r\n    }\r\n\r\n    subscribe(observer){\r\n        this.observers.push(observer);\r\n    }\r\n\r\n    notify(data) {\r\n        this.observers.forEach(observer => observer(data));\r\n    }\r\n\r\n}\r\n\r\nclass PyodideInWebWorkerStrategy {\r\n    constructor(){\r\n        this._setupWorker();\r\n        this._initInterruptBuffer();\r\n    }\r\n\r\n    execute(code) {\r\n        this.setStatus('running');\r\n        this.worker.postMessage({ type: \"RUN\", code: code});\r\n    }\r\n\r\n    executeSQL(queryWrapper) {\r\n        this.worker.postMessage({ type: \"RUN_SQL\", queryWrapper : queryWrapper});\r\n    }\r\n\r\n    interrupt(){\r\n        if (this.interruptBuffer){\r\n            this._sendKeyboardInterrupt();\r\n            this._setInterruptBuffer();\r\n            this.setStatus('ready');\r\n        }\r\n        else{\r\n            this.worker.terminate();\r\n            this.setStatus('reseting');\r\n            this._setupWorker();\r\n            this.installPackages();\r\n        }\r\n    }\r\n\r\n    installPackages() {\r\n        this.worker.postMessage({ type: \"INSTALL\", packages: this.packages });\r\n    }\r\n\r\n    initiateDBs(){\r\n        this.worker.postMessage({ type: \"INIT_DB\", databaseInitQuery: this.databaseInitQuery });\r\n    }\r\n\r\n    setPackages(packages){\r\n        this.packages = packages;\r\n    }\r\n\r\n    setDatabaseInitQuery(databaseInitQuery){\r\n        this.databaseInitQuery = databaseInitQuery;\r\n    }\r\n    setStatusCallback(statusCallback){\r\n        this.setStatus = statusCallback;\r\n    }\r\n\r\n    _setInterruptBuffer(){\r\n        this.interruptBuffer[0] = 2;\r\n    }\r\n\r\n    _setupWorker(){\r\n        this.worker = new Worker('../../web-worker.js');\r\n        this.worker.postMessage({ type: \"LOAD_PYODIDE\"});\r\n        this._setupListeners();\r\n    }\r\n\r\n    _setupListeners(){\r\n        this.worker.onmessage = (event) => {\r\n            if (event.data.type === \"PYODIDE_READY\") {\r\n                if(this.interruptBuffer)\r\n                    this.worker.postMessage({ type: \"SET_INTERRUPT_BUFFER\", interruptBuffer: this.interruptBuffer });\r\n            }\r\n            if (event.data.type === \"PACKAGES_INSTALLED\") {\r\n                if (this.databaseInitQuery.length > 0){\r\n                    this.initiateDBs();\r\n                }\r\n                else{\r\n                    this.setStatus('ready');         \r\n                }\r\n            }\r\n            if (event.data.type === \"DB_INITIALIZED\") {\r\n                this.setStatus('ready');\r\n            }\r\n            if (event.data.type === 'STDOUT') {\r\n               writeToOutput(event.data.text);\r\n            }\r\n            if (event.data.type === \"ERR\") {\r\n               reportError();\r\n            }\r\n            if (event.data.type === \"SQL_ERR\") {\r\n                reportSQLError(event.data.err);\r\n            }\r\n            if (event.data.type === 'CODE_EXECUTED') {\r\n                this.setStatus('ready');\r\n            }\r\n            if (event.data.type === 'SQL_CODE_EXECUTED') {\r\n                writeToOutput(event.data.result);\r\n                this.setStatus('ready');\r\n            }\r\n        }\r\n    }\r\n\r\n    _initInterruptBuffer(){\r\n        try{\r\n            this.interruptBuffer = new Uint8Array(new SharedArrayBuffer(1));\r\n        }\r\n        catch(e){\r\n            this.interruptBuffer = null;\r\n        }\r\n    }\r\n\r\n    _sendKeyboardInterrupt(){\r\n        let swRef = getServiceWorkerReference();\r\n        swRef.postMessage({\r\n            type: 'PY_INPUT',\r\n            value: \"\"\r\n        });\r\n    }\r\n}\r\n\r\nclass PyodideInMainThreadStrategy {\r\n    microPipLoaded = false;\r\n    constructor(){}\r\n    \r\n    async initiate() {\r\n        this.pyodide = await self.loadPyodide({\r\n            stdout: (text) => {\r\n                writeToOutput(text);\r\n            },\r\n            stderr: (text) => {\r\n                writeToOutput(text);\r\n            },\r\n            stdin: (text) => prompt(text)\r\n          });\r\n        await this._patchInput();\r\n        await this._patchOutput();\r\n    }\r\n\r\n    async execute(code) {\r\n        this.setStatus('running');\r\n        try{\r\n            await this.pyodide.runPythonAsync(`run_code('''${code}''')`)\r\n        }catch(e){\r\n            reportError();\r\n        }\r\n        finally{\r\n            this.setStatus('ready');\r\n        }\r\n    }\r\n\r\n    executeSQL(queryWrapper) {\r\n\r\n            let result = this.pyodide.runPython(queryWrapper);\r\n            if (result.get('error')) {\r\n                reportSQLError(result.get('error'));\r\n            }\r\n            else{\r\n                writeToOutput(result);\r\n            }\r\n    }\r\n    \r\n    interrupt(){\r\n        // Not supported\r\n        console.log(\"Reset not supported when using pyodide in main thread\");\r\n    }\r\n\r\n    async installPackages() {\r\n        // add error handling for package installation\r\n        if (!this.microPipLoaded) {\r\n            await this.pyodide.loadPackage(['micropip']);\r\n            this.micropip = this.pyodide.pyimport('micropip');\r\n            this.microPipLoaded = true;\r\n        }\r\n        this.packages.forEach(async (p) => {\r\n          await this.micropip.install(p)\r\n        });\r\n        if (this.databaseInitQuery.length > 0){\r\n            await this.initiateDBs();\r\n        }\r\n        this.setStatus('ready');\r\n    }\r\n\r\n    setPackages(packages){\r\n        this.packages = packages;\r\n    }\r\n\r\n    setDatabaseInitQuery(databaseInitQuery){\r\n        this.databaseInitQuery = databaseInitQuery;\r\n    }\r\n\r\n    setStatusCallback(statusCallback){\r\n        this.setStatus = statusCallback;\r\n    }\r\n\r\n    async _patchInput(){\r\n        const patchInputCode = `\r\nfrom js import prompt\r\n\r\ndef input(p = \"\"):\r\n    print(p)\r\n    return prompt(p)\r\n    \r\n__builtins__.input = input\r\n`\r\n        await this.pyodide.runPythonAsync(patchInputCode);;\r\n    }\r\n\r\n    async _patchOutput(){\r\n        const patchOutputCode = `\r\nimport sys, io, traceback\r\ndef run_code(code):\r\n    try:\r\n        exec(code, {})\r\n    except:\r\n        tb = traceback.format_exc().split(\"\\\\n\")\r\n        tb = tb[:1] + tb[2:] # Remove run_code from traceback\r\n        print(\"\\\\n\".join(tb))\r\n        raise\r\n`\r\n        await this.pyodide.runPythonAsync(patchOutputCode);\r\n    }\r\n\r\n    async initiateDBs(){\r\n        const pythonInitCode = `from sqlite_easy import *\r\ndata_base_connections = {}`;\r\n        const pythonCreateDatabaseCode = (name, query) => `data_base_connections['''${name}'''] = create_database('''${name}''', '''${query}''')`;\r\n\r\n        let names = this.databaseInitQuery.map((x) => x['name']);\r\n        let queries = this.databaseInitQuery.map((x) => x['databaseInitQuery']);\r\n\r\n        const sqliteEasyPackage =  fetch(\"../_static/sqlite_easy.zip\").then((x) => x.arrayBuffer());;\r\n        const pkg = await sqliteEasyPackage;\r\n        await this.pyodide.unpackArchive(pkg, \"zip\");\r\n\r\n        await this.pyodide.loadPackage(['sqlite3'])\r\n        this.pyodide.runPython(pythonInitCode);\r\n\r\n        for (let i = 0; i < this.databaseInitQuery.length; i++){\r\n            this.pyodide.runPython(pythonCreateDatabaseCode(names[i], queries[i]));\r\n        }\r\n    }\r\n}\r\n\r\n\r\nasync function getUserInput(prompt) {\r\n    let pyCodeInstance = document.getElementById(currentId.get())\r\n    return pyCodeInstance.getUserInput(prompt);\r\n  }\r\n  \r\n  function writeToOutput(text) {\r\n    let pyCodeInstance = document.getElementById(currentId.get())\r\n    pyCodeInstance.writeToOutput(text);\r\n  }\r\n  \r\n  function reportError(){\r\n    let pyCodeInstance = document.getElementById(currentId.get())\r\n    pyCodeInstance.reportError();\r\n}\r\n\r\nfunction reportSQLError(err){\r\n    let pyCodeInstance = document.getElementById(currentId.get())\r\n    pyCodeInstance.reportSQLError(err);\r\n}\r\n\r\nfunction isInIframe() {\r\n    try {\r\n      return window.self !== window.top;\r\n    } catch (e) {\r\n      return true;\r\n    }\r\n  }\r\n  \r\n  function isFirefox() {\r\n    return navigator.userAgent.includes('Firefox');\r\n  }\r\n  \r\n  function isSafari() {\r\n    return navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome');\r\n  }\r\n  \r\n  function isHttps() {\r\n    return window.location.protocol === 'https:' || window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';\r\n  }\r\n\r\nconst shouldUseMainThread = (isInIframe() && isFirefox()) || isSafari() || !isHttps();\r\nlet pythonExecutorInstancePromise = null;\r\nlet getServiceWorkerReference = null;\r\n\r\nasync function createPythonExecutor() {\r\n    if (pythonExecutorInstancePromise === null) {\r\n        // Only create a new instance if one doesn't already exist\r\n        pythonExecutorInstancePromise = (async () => {\r\n            let strategy;\r\n            let serviceWorkerReference;\r\n            try{\r\n                getServiceWorkerReference = await registerServiceWorker(getUserInput);\r\n                serviceWorkerReference = getServiceWorkerReference();\r\n            }\r\n            catch(e){\r\n                serviceWorkerReference = null;\r\n            }\r\n\r\n            if (shouldUseMainThread || serviceWorkerReference === null){\r\n                strategy = new PyodideInMainThreadStrategy();\r\n                await strategy.initiate();\r\n            } else {\r\n                strategy = new PyodideInWebWorkerStrategy();\r\n            }\r\n            return new PythonExecutor(strategy);\r\n        })();\r\n    }\r\n    return await pythonExecutorInstancePromise;\r\n}\r\n\r\n\r\nasync function registerServiceWorker(getUserInput) {\r\n    if ('serviceWorker' in navigator) {\r\n        try {\r\n            const registration = await navigator.serviceWorker.register('../../service-worker.js')\r\n            let swRef = registration.active;\r\n\r\n            registration.addEventListener('updatefound', () => {\r\n                const installingWorker = registration.installing;\r\n                if (installingWorker) {\r\n                    installingWorker.addEventListener('statechange', () => {\r\n                        if (installingWorker.state === 'installed') {\r\n                            swRef = installingWorker;\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n\r\n            navigator.serviceWorker.onmessage = (event) => {\r\n                if (event.data.type === 'PY_AWAITING_INPUT') {\r\n                    if (event.source instanceof ServiceWorker) {\r\n                        swRef = event.source;\r\n                        getUserInput(event.data.prompt)\r\n                            .then((value) => {\r\n                                swRef.postMessage({\r\n                                    type: 'PY_INPUT',\r\n                                    value\r\n                                });\r\n                            });\r\n                    }\r\n                }\r\n            };\r\n\r\n            return () => swRef;\r\n        } catch (error) {\r\n            throw new Error('Service worker registration failed: ' + error);\r\n        }\r\n    } else {\r\n        throw new Error('Service workers not supported');\r\n    }\r\n}\r\n\r\n\r\n  \r\nif (!window.isPythonExecutorEventListenerSet) {\r\n    window.addEventListener('load', async function (event) {\r\n        const components = ['py-code', 'db-query'];\r\n        let pyodide = await createPythonExecutor()\r\n        let dbInstances = document.querySelectorAll(components.join(','));\r\n        await Promise.all(Array.from(dbInstances).map(async (dbInstance) => {\r\n            await dbInstance.setPyodide(pyodide);\r\n        }));\r\n        await pyodide.initiate();\r\n    })\r\n    window.isPythonExecutorEventListenerSet = true;\r\n}\n\n//# sourceURL=webpack://plct-web-components/./src/python-kernel/python-executor.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/python-kernel/python-executor.js"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;