from __future__ import annotations
import logging
import re
from pathlib import Path
import sys
from django.conf import settings
from django.core.management import base, call_command
from django.apps import AppConfig, apps as all_apps

logger = logging.getLogger(__name__)


class Command(base.BaseCommand):
    REINITMIGRATIONS_SEALED: dict[str,int] = getattr(settings, "REINITMIGRATIONS_SEALED", {})
    REINITMIGRATIONS_ORDER: list[str] = getattr(settings, "REINITMIGRATIONS_ORDER", [])
    _migration_name_re = re.compile(r"^(\d+)_")


    def add_arguments(self, parser):
        parser.add_argument("-x", "--exclude", nargs='*', dest="exclude_apps", metavar='apps', help="label of apps to exclude from migrations remaking")
        parser.add_argument("apps", nargs="*", help="label of apps for which migrations are remade")


    def handle(self, apps: list[str] = [], exclude_apps: list[str] = None, **kwargs):
        app_configs = self.get_app_configs(apps, exclude_apps)
        
        renamed = self.handle_existing_migrations(app_configs.values())

        for label in self.REINITMIGRATIONS_ORDER:
            if label in app_configs:        
                logger.info("makemigrations %s", label)
                call_command("makemigrations", label)

        if any(label not in self.REINITMIGRATIONS_ORDER for label in app_configs):
            logger.info("makemigrations")
            call_command("makemigrations")

        self.restore_renamed_migrations(renamed)
        

    def get_app_configs(self, apps: list[str], exclude_apps: list[str]):
        app_configs: dict[str,AppConfig] = {}

        if apps:
            for label in apps:
                if not label in app_configs and (not exclude_apps or label not in exclude_apps):
                    app_configs[label] = all_apps.get_app_config(label)
        else:
            for config in all_apps.get_app_configs():
                if exclude_apps and config.label in exclude_apps:
                    pass
                elif Path(sys.prefix) in Path(config.path).parents:
                    # exclude apps located in venv / python packages
                    pass
                elif not config.label in app_configs:
                    app_configs[config.label] = config

        return app_configs


    def get_migration_number(self, path: Path):
        m = self._migration_name_re.match(path.name)
        if not m:
            return None

        return int(m.group(1))
    

    def is_generated_migration(self, path: Path):
        with open(path) as fp:
            begining = fp.read(100)
            return '# Generated by Django ' in begining
        

    def is_sealed_migration(self, app_label: str, path: Path):
        if not self.REINITMIGRATIONS_SEALED:
            return False
        if not app_label in self.REINITMIGRATIONS_SEALED:
            return False
        
        migration_number = self.get_migration_number(path)
        if migration_number is None:
            logger.warning(f"preserve (no migration number): {path}")
            return True
        elif migration_number <= self.REINITMIGRATIONS_SEALED[app_label]:
            logger.info(f"preserve (sealed: app {app_label} migration <= {self.REINITMIGRATIONS_SEALED[app_label]}): {path}")
            return True
        else:
            return False
    

    def handle_existing_migrations(self, app_configs: list[AppConfig]):
        """
        Delete generated migrations and rename non-generated migrations to `.py~` extension.
        """
        renamed: dict[Path,Path] = {}

        for app_config in app_configs:
            for path in Path(app_config.path).joinpath('migrations').glob('0*.py'):
                renamed_path = self.handle_existing_migration(path, app_label=app_config.label)
                if renamed_path:
                    renamed[path] = renamed_path

        return renamed
            

    def handle_existing_migration(self, path: Path, app_label: str):
        if not self.is_generated_migration(path):
            renamed_path = path.with_name(f"{path.name}~")
            logger.info(f"rename {path} to {renamed_path}")
            path.rename(renamed_path)
            return renamed_path

        for part in path.parts:
            if part.startswith('.'):
                logger.debug(f"preserve (hidden): {path}")
                return None

            if re.match(r'^\d+\-', part):
                logger.debug(f"preserve (digit+hyphen): {path}")
                return None

        if self.is_sealed_migration(app_label, path):
            logger.info(f"preserve (sealed): {path}")
            return None

        logger.info(f"delete {path}")
        path.unlink()
        return None

    
    def restore_renamed_migrations(self, renamed: dict[Path,Path]):
        """ Restore migrations from py~ """
        for origin, newpath in renamed.items():
            logger.info(f"rename {newpath} to {origin}")
            newpath.rename(origin)
