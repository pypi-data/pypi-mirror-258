from typing import Optional
from warnings import warn
from functools import reduce
from operator import xor

import numpy as np
from numpy.typing import ArrayLike, NDArray

class BerlekampMasseyError(ValueError):
    '''Raised when the BM algorithm cannot find a polynomial that is generated by
    sequence or fits the constraints of poly_length or is_primitive.'''
    pass


class BerlekampMassey():
    def __init__(self,
                 sequence: ArrayLike,
                 poly_length: Optional[int] = None,
                 is_primitive: Optional[bool] = None,
                 ):
        ''' Given a sequence 'sequence' finds a minimum-length generator polynomial
        that generates this sequence. Optionally, the polynomial can be specified 
        to have a certain length or to be primitive.
        '''
        self.sequence = sequence
        self.poly_length = poly_length
        self.is_primitive = is_primitive
        self.est_poly = np.array([1]) #f(x), current polynomial estimate
        self._g_x = np.array([1])  #g(x), used for updating f(x)
        self.position = 0 #index in the provided sequence
        self._m = -1 #last index where g(x) is correct

    def __len__(self):
        return len(self.est_poly)
    
    def estimate_polynomial(self):
        '''Essential function of BM. The result is that est_poly represents, if possible
        the estimated polynomial that generates the provided sequence.
        '''
        for k in range(len(self.sequence)):
            self._update_estimate(self.sequence[:k+1])
            self.position += 1
        
        return self.est_poly

    def _update_estimate(self, bits: NDArray) -> None:
        ''' Implmentation of polynomial estimate update given a new bit observation. This 
        operation is state-aware and should only be executed in conjunction with 
        incrementing self.position _and_ providing a new bit from the bit sequence. 
        Unexpected behavior should be expected otherwise. The provided parameter should be
        all bits from the input sequence up to and including the bit in position 
        self.position. Bits should be ordered via [s_0, s_1, ..., s_self.position].
        '''
        masked_bits = np.flip(bits)[:len(self)] & self.est_poly
        discrepancy = reduce(xor, masked_bits)
        if discrepancy == 1:
            g_shift = self.position - self._m
            temp_g_x = np.roll(np.r_[self._g_x, np.zeros(g_shift).astype(int)], g_shift)
            order_inc = np.max([0, len(temp_g_x) - len(self)])
            if order_inc > 0: #Update g(x)
                self._g_x = self.est_poly
                self._m = self.position
                padded_poly = np.r_[self.est_poly, np.zeros(order_inc).astype(int)]
                padded_update = temp_g_x
            else:
                padded_poly = self.est_poly 
                padded_update = np.r_[temp_g_x, np.zeros(len(self)-len(temp_g_x)).astype(int)]
            self.est_poly =  padded_poly ^ padded_update

    #Class properties
    @property
    def sequence(self):
        return self._sequence
    
    @sequence.setter
    def sequence(self, value):
        if isinstance(value, list):
            value = np.array(value)
        if len(value) == 0: 
            raise BerlekampMasseyError('You must provide a sequence of at least one bit.')
        if not (np.all((value==1) ^ (value==0))):
            raise ValueError('The provided sequence must be include only valid numerical bits.')
        
        self._sequence = value.astype(int)

    @property
    def poly_length(self):
        return self._poly_length
    
    @poly_length.setter
    def poly_length(self, value):
        if isinstance(value, float):
            warn('The provided polynomial length was not an integer and will be coerced to one.')
            value = int(value)
        self._poly_length = value

    @property
    def is_primitive(self):
        return self._is_primitive
    
    @is_primitive.setter
    def is_primitive(self, value):
        if not (isinstance(value, type(None)) or isinstance(value, bool)):
            raise TypeError('If specified is_primitive must be a boolean.')
        self._is_primitive = value

