# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_core.ipynb.

# %% auto 0
__all__ = ['T', 'K', 'P', 'isnone', 'istype', 'getname', 'private', 'mangled', 'unmangle', 'unmangled_annotations',
           'typed_dict_signature', 'typed_dict_defaults', 'typed_dict_func', 'get_typed_dict_keywords', 'typedict',
           'dtyp', 'new', 'setkeywords']

# %% ../nbs/01_core.ipynb 6
from inspect import Signature, Parameter, get_annotations
from functools import wraps, partial

# %% ../nbs/01_core.ipynb 8
from typing import Self, Type, Callable, TypeVar, ParamSpec, TypeGuard, TypedDict

# %% ../nbs/01_core.ipynb 10
#| export


# %% ../nbs/01_core.ipynb 12
# from nchr import U2
# from nlit import DCT, NON, SIG, SUBCLASS
# from nlit import __MODULE__, __NAME__, __QUALNAME__, __DOC__
# from chck import isnone, istype

# %% ../nbs/01_core.ipynb 14
#| export


# %% ../nbs/01_core.ipynb 16
# NOTE: T = TypeVar('T', bound=TypedDict) is not valid since TypedDict is not a class
T = TypeVar('T', bound=dict)
K = TypeVar('K', bound=dict) 
P = ParamSpec('P')

# %% ../nbs/01_core.ipynb 18
def isnone(x) -> TypeGuard[None]:
    return x is None

def istype(x) -> TypeGuard[type]:
    return isinstance(x, type)

# %% ../nbs/01_core.ipynb 20
U1, U2 = '_', '__'
DCT, NON, SIG, SUBCLASS = 'dct', 'non', 'sig', 'subclass'
__MODULE__, __NAME__, __QUALNAME__, __DOC__ = '__module__', '__name__', '__qualname__', '__doc__'

__DCT, __NON, __SIG, __SUBCLASS = f'{U2}{DCT}', f'{U2}{NON}', f'{U2}{SIG}',  f'{U2}{SUBCLASS}'

# %% ../nbs/01_core.ipynb 23
def getname(obj) -> str:
    return getattr(obj, __NAME__, getattr(obj, __QUALNAME__, str(obj)))

def private(attr: str) -> str:
    return f'{U1}{attr.lstrip(U1)}'

def mangled(cls: object, attr: str) -> str:
    return f'{private(getname(cls))}{U2}{attr.lstrip(U2)}'

def unmangle(cls: object, attr: str) -> str:
    return attr.split(private(getname(cls)))[-1]

# %% ../nbs/01_core.ipynb 25
def unmangled_annotations(cls: T) -> dict:
    return {unmangle(cls, k): v for k, v in get_annotations(cls).items()}

# %% ../nbs/01_core.ipynb 28
def typed_dict_signature(__dct: T, **kwargs: K) -> Signature:
    '''Generates a Signature object representing the signature of a TypedDict.

    Parameters
    ----------
    __dct : TypedDict
        The TypedDict class for which the signature is generated.
    **kwargs : TypedDict
        Default values for the TypedDict fields, if any.

    Returns
    -------
    Signature
        A Signature object representing the TypedDict's field names, types, and default values.
    '''
    anns = get_annotations(__dct)
    kwds, prms = list(anns.keys()), list()
    
    for kwd, ann in zip(kwds, anns.values()):
        
        val = kwargs.get(kwd, None)
        if isnone(val) and istype(ann):
            try: 
                val = ann()
            except: 
                val = None
                
        prm = Parameter(kwd, Parameter.POSITIONAL_OR_KEYWORD, annotation=ann, default=val)
        prms.append(prm)
        
    return Signature(prms, return_annotation=__dct)

# %% ../nbs/01_core.ipynb 31
def typed_dict_defaults(
    __dct: T, *, 
    __sig: Signature | None = None, 
    __non: bool = True, 
    **kwargs: K
) -> T:
    '''Creates an instance of a TypedDict with default values specified either in the 
    signature or as keyword arguments.

    Parameters
    ----------
    __dct : TypedDict
        The TypedDict class for which the instance is created.
    __sig : Signature, optional
        A predefined Signature object for the TypedDict, if available.
    __non : bool, default True
        If True, non-specified fields will be included with `None` values.
    **kwargs : TypedDict
        Overrides for default values specified in the signature.

    Returns
    -------
    T
        An instance of the TypedDict with default values set.
    '''
    sig = __sig or typed_dict_signature(__dct, **kwargs)
    
    defaults = {
        k: v.default for k, v in sig.parameters.items() 
        if v.default is not Parameter.empty
    }
    
    defaults.update({k:v for k,v in kwargs.items() if k in defaults})
    if not __non: defaults = {k:v for k,v in defaults.items() if not isnone(v)}
    return __dct(**defaults)

# %% ../nbs/01_core.ipynb 33
def typed_dict_func(
    __dct: T, __sig: Signature | None = None,
    __non: bool = True, 
) -> Callable[[T, Signature], Callable[P, T]]:
    '''Returns a partial function for creating TypedDict instances with defaults 
    and potentially non-values excluded.

    Parameters
    ----------
    __dct : TypedDict
        The TypedDict class for which instances will be created.
    __sig : Signature, optional
        The signature to use for the TypedDict. If not provided, it will be generated.
    __non : bool, default True
        Determines whether non-values (None) should be included in the output.

    Returns
    -------
    Callable
        A partial function that can be used to create instances of the TypedDict.
    '''
    return partial(typed_dict_defaults, __dct, __sig=__sig, __non=__non)

# %% ../nbs/01_core.ipynb 37
def get_typed_dict_keywords(
    __dct: T, 
    __pop_keyword: bool = True, 
    __defaults: T | None = None, 
    **kwargs: K
) -> T:
    '''Get the keywords arguments as specified in a `TypedDict`.
    
    Parameters
    ----------
    __pop_keyword : bool, default: True
        Whether to remove the keyword from the `kwargs` dictionary, by default True
        
    __defaults : T, optional
        The default values for the `TypedDict`, by default None
        
    kwargs : dict
        The keyword arguments to be added to the `TypedDict`
        
    Returns
    -------
    T
        The `TypedDict` with the keyword arguments added
    '''
    kwds = __defaults or {}
    anns = get_annotations(__dct)
    # unmangled annotation names
    unmg = unmangled_annotations(__dct)
    keys = list(kwargs.keys())
    for key in keys:
        mkw = mangled(__dct, key) # mangled keyword name
        if (
            key in unmg or # key is in the unmangled keywords
            key in anns or # key is a mangled keyword
            mkw in anns # if the mangled keyword is in the annotations
        ): 
            ukw = unmangle(__dct, key)    # unmangled the keyword name
            kwds[ukw] = kwargs.get(key) # add the unmangled keyword and its value to the result
            if __pop_keyword:  kwargs.pop(key, None)
            continue
    return kwds

# %% ../nbs/01_core.ipynb 39
def prune_type_dict_keywords(__dct: T, **kwargs) -> T:
    keys = set()
    anns = get_annotations(__dct)
    unmg = unmangled_annotations(__dct)
    for key in kwargs:
        mkw = mangled(__dct, key)
        if (key in unmg or key in anns or mkw in anns): 
            keys.add(key)
    return dict(((k, v) for k, v in kwargs.items() if k not in keys))

# %% ../nbs/01_core.ipynb 41
class typedict(dict):
    '''A base class for creating TypedDict instances with default values and custom behaviors.

    Subclasses can specify TypedDict types and default values for their fields.
    '''
    def __init_subclass__(cls: Type[Self], **defs: K) -> None:
        '''
        Initializes a subclass with specified TypedDict defaults and optional custom signature.

        Parameters
        ----------
        **defs : TypedDict
            Defaults and TypedDict specifications for the subclass.

        Raises
        ------
        KeyError
            If __dct is not provided in the subclass definition.
        '''
        super().__init_subclass__()
        sub = defs.pop('__subclass', False)

        try:
            cls.__dct = defs.pop('__dct')
            cls.__non = defs.pop('__non', True)
            cls.__sig = defs.pop('__sig', typed_dict_signature(cls.__dct, **defs))
            
        except KeyError as err:
            if not sub: raise err
        return
    
    def __init__(self: Self, *args, **kwargs):
        '''Initializes an instance of the subclass with default values and optional overrides.

        Parameters
        ----------
        *args
            Unused, present to comply with the dict interface.
        **kwargs
            Field values that override the defaults specified in the subclass.
        '''
        kwargs.pop('__dct', None)
        kwargs.pop('__sig', None)
        __non = kwargs.pop('__non', True)
        kwds = typed_dict_defaults(type(self).__dct, __sig=type(self).__sig, __non=__non, **kwargs)
        super().__init__(*args, **kwds)
        
    def __instancecheck__(self, __instance) -> bool:
        '''Checks if the instance is of the TypedDict type specified in the subclass.

        Parameters
        ----------
        __instance
            The instance to check.

        Returns
        -------
        bool
            True if the instance is of the correct TypedDict type, False otherwise.
        '''
        return super().__instancecheck__(__instance) or isinstance(__instance, type(self).__dct)
    
    def dropnones(self: Self, inplace: bool = True) -> Self:
        '''Removes keys with `None` values from the TypedDict instance.

        Parameters
        ----------
        inplace : bool, default True
            If True, modifies the instance in place; otherwise, returns a new instance without `None` values.

        Returns
        -------
        Self
            The instance itself if inplace is True, otherwise a new instance.'''
        bad = {k for k, v in self.items() if isnone(v)}
        if inplace:
            for k in bad: self.pop(k)
            return self
        sub = {k: v for k, v in self.items() if k in bad}
        return type(self)(sub)
    
    @classmethod
    def filter(cls: Type[Self], __defaults: T | None = None, **kwargs: K) -> Self: 
        '''Filter the keywords in **kwargs to just those specified in the class's TypedDict.

        Parameters
        ----------
        __defaults : T, optional
            The default values for the `TypedDict`, by default None
            
        kwargs : dict
            The keyword arguments to be added to the `TypedDict`
            
        Returns
        -------
        Self
            An instance of the `TypedDict` with the keyword arguments added
        '''
        return get_typed_dict_keywords(cls.__dct, __defaults=__defaults, **kwargs)
    
    @classmethod
    def remove(cls: Type[Self], **kwargs: K): 
        '''Remove the keywords in **kwargs from the class's TypedDict'''
        return prune_type_dict_keywords(cls.__dct, **kwargs)
        return cls(prune_type_dict_keywords(cls.__dct, **kwargs))

# %% ../nbs/01_core.ipynb 43
@wraps(typedict, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__), updated=())
class dtyp(typedict, __subclass=True): 
    ...

# %% ../nbs/01_core.ipynb 48
def new(d: T, **kwargs: K):
    '''A decorator for creating new typedict subclasses from a 
    TypedDict definition with specified defaults.

    Parameters
    ----------
    d : TypedDict
        The TypedDict definition to base the subclass on.
    **kwargs : TypedDict
        Default values for the TypedDict fields.

    Returns
    -------
    Callable
        A decorator that when applied to a class, modifies it to be a typedict subclass.
    '''
    
    def decorator(func: Callable):
        '''A decorator for functions to automatically fill in TypedDict 
        based on its signature and provided defaults.

        Parameters
        ----------
        d : TypedDict
            The TypedDict definition to base the argument filling on.
        **kwargs : TypedDict
            Default values for the TypedDict fields.

        Returns
        -------
        Callable
            A decorator that when applied to a function, wraps it so that its keyword 
            arguments are filled in based on the TypedDict and defaults.
        '''
        __non = kwargs.pop('__non', True)
        signature = typed_dict_signature(d, **kwargs)
        
        @wraps(typedict, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__), updated=())
        class wrapper(typedict, __dct=d, __sig=signature, __non=__non, __subclass=True):
            ...
        wrapper.__signature__ = signature
        wrapper.__annotations__ = d.__annotations__
        try: 
            wrapper.__doc__  = d.__doc__
            wrapper.__call__ = d.__doc__
            wrapper.__init__.__signature__ = signature
            wrapper.__init__.__annotations__ = d.__annotations__
            wrapper.__annotations__ = d.__annotations__
        except: pass
        return wrapper
    
    return decorator

# %% ../nbs/01_core.ipynb 51
def setkeywords(d: T, **kwargs: K):
    
    def decorator(func: Callable):
        dropnones = kwargs.pop('__non', True)
        signature = typed_dict_signature(d, **kwargs)
        construct = typed_dict_func(d, signature, dropnones)
        
        @wraps(func, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__))
        def wrapper(**kwargs: Type[d]) -> Type[d]:
            kwds = construct(**kwargs)
            return d(**kwds)
        wrapper.__signature__ = signature
        return wrapper
    
    return decorator
