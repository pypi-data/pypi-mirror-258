# coding: utf-8

"""
    IcoTest Voice

    IcoTest Voice API  # noqa: E501

    The version of the OpenAPI document: 1.0.41
    Contact: shaun.hirst@3adesign.co.uk
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from icotest_voice.api_client import ApiClient
from icotest_voice.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class RequestsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def dect_get_last_commands(self, device_id, commands_type, commands_num, **kwargs):  # noqa: E501
        """DECT Get Last Commands  # noqa: E501

        Retrieve the last commands to/from a DECT device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dect_get_last_commands(device_id, commands_type, commands_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str device_id: the unique ID of the DECT device (required)
        :param str commands_type: The type of commands to retrieve: `to_dongle` or `from_dongle` (required)
        :param int commands_num: The number of commands to retrieve (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.dect_get_last_commands_with_http_info(device_id, commands_type, commands_num, **kwargs)  # noqa: E501

    def dect_get_last_commands_with_http_info(self, device_id, commands_type, commands_num, **kwargs):  # noqa: E501
        """DECT Get Last Commands  # noqa: E501

        Retrieve the last commands to/from a DECT device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dect_get_last_commands_with_http_info(device_id, commands_type, commands_num, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str device_id: the unique ID of the DECT device (required)
        :param str commands_type: The type of commands to retrieve: `to_dongle` or `from_dongle` (required)
        :param int commands_num: The number of commands to retrieve (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[str], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'device_id',
            'commands_type',
            'commands_num'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dect_get_last_commands" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'device_id' is set
        if self.api_client.client_side_validation and ('device_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['device_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `device_id` when calling `dect_get_last_commands`")  # noqa: E501
        # verify the required parameter 'commands_type' is set
        if self.api_client.client_side_validation and ('commands_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['commands_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `commands_type` when calling `dect_get_last_commands`")  # noqa: E501
        # verify the required parameter 'commands_num' is set
        if self.api_client.client_side_validation and ('commands_num' not in local_var_params or  # noqa: E501
                                                        local_var_params['commands_num'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `commands_num` when calling `dect_get_last_commands`")  # noqa: E501

        if self.api_client.client_side_validation and ('device_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['device_id']) > 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `device_id` when calling `dect_get_last_commands`, length must be less than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and ('device_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['device_id']) < 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `device_id` when calling `dect_get_last_commands`, length must be greater than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and 'device_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['device_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `device_id` when calling `dect_get_last_commands`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        if self.api_client.client_side_validation and 'commands_num' in local_var_params and local_var_params['commands_num'] > 100:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `commands_num` when calling `dect_get_last_commands`, must be a value less than or equal to `100`")  # noqa: E501
        if self.api_client.client_side_validation and 'commands_num' in local_var_params and local_var_params['commands_num'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `commands_num` when calling `dect_get_last_commands`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'device_id' in local_var_params:
            path_params['device_id'] = local_var_params['device_id']  # noqa: E501

        query_params = []
        if 'commands_type' in local_var_params and local_var_params['commands_type'] is not None:  # noqa: E501
            query_params.append(('commands_type', local_var_params['commands_type']))  # noqa: E501
        if 'commands_num' in local_var_params and local_var_params['commands_num'] is not None:  # noqa: E501
            query_params.append(('commands_num', local_var_params['commands_num']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/requests/{device_id}/DECT_get_last_commands', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_appium_all_screenshots(self, controller_id, **kwargs):  # noqa: E501
        """DELETE APPIUM all screenshots  # noqa: E501

        Delete all screenshots  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_appium_all_screenshots(controller_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_appium_all_screenshots_with_http_info(controller_id, **kwargs)  # noqa: E501

    def delete_appium_all_screenshots_with_http_info(self, controller_id, **kwargs):  # noqa: E501
        """DELETE APPIUM all screenshots  # noqa: E501

        Delete all screenshots  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_appium_all_screenshots_with_http_info(controller_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'controller_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_appium_all_screenshots" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'controller_id' is set
        if self.api_client.client_side_validation and ('controller_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['controller_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `controller_id` when calling `delete_appium_all_screenshots`")  # noqa: E501

        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) > 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `delete_appium_all_screenshots`, length must be less than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) < 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `delete_appium_all_screenshots`, length must be greater than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and 'controller_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['controller_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `delete_appium_all_screenshots`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'controller_id' in local_var_params:
            path_params['controller_id'] = local_var_params['controller_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/requests/{controller_id}/APPIUM_delete_all_screenshots', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_appium_ios_certificates(self, controller_id, **kwargs):  # noqa: E501
        """DELETE APPIUM audio playback file  # noqa: E501

        Delete ios certificates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_appium_ios_certificates(controller_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_appium_ios_certificates_with_http_info(controller_id, **kwargs)  # noqa: E501

    def delete_appium_ios_certificates_with_http_info(self, controller_id, **kwargs):  # noqa: E501
        """DELETE APPIUM audio playback file  # noqa: E501

        Delete ios certificates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_appium_ios_certificates_with_http_info(controller_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'controller_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_appium_ios_certificates" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'controller_id' is set
        if self.api_client.client_side_validation and ('controller_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['controller_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `controller_id` when calling `delete_appium_ios_certificates`")  # noqa: E501

        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) > 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `delete_appium_ios_certificates`, length must be less than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) < 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `delete_appium_ios_certificates`, length must be greater than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and 'controller_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['controller_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `delete_appium_ios_certificates`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'controller_id' in local_var_params:
            path_params['controller_id'] = local_var_params['controller_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/requests/{controller_id}/APPIUM_delete_ios_certificates', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_audio_playback_file(self, controller_id, playback_file, **kwargs):  # noqa: E501
        """DELETE audio playback file  # noqa: E501

        Delete audio playback file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_audio_playback_file(controller_id, playback_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param str playback_file: the filename of the playback file (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_audio_playback_file_with_http_info(controller_id, playback_file, **kwargs)  # noqa: E501

    def delete_audio_playback_file_with_http_info(self, controller_id, playback_file, **kwargs):  # noqa: E501
        """DELETE audio playback file  # noqa: E501

        Delete audio playback file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_audio_playback_file_with_http_info(controller_id, playback_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param str playback_file: the filename of the playback file (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'controller_id',
            'playback_file'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_audio_playback_file" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'controller_id' is set
        if self.api_client.client_side_validation and ('controller_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['controller_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `controller_id` when calling `delete_audio_playback_file`")  # noqa: E501
        # verify the required parameter 'playback_file' is set
        if self.api_client.client_side_validation and ('playback_file' not in local_var_params or  # noqa: E501
                                                        local_var_params['playback_file'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `playback_file` when calling `delete_audio_playback_file`")  # noqa: E501

        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) > 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `delete_audio_playback_file`, length must be less than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) < 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `delete_audio_playback_file`, length must be greater than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and 'controller_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['controller_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `delete_audio_playback_file`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'controller_id' in local_var_params:
            path_params['controller_id'] = local_var_params['controller_id']  # noqa: E501

        query_params = []
        if 'playback_file' in local_var_params and local_var_params['playback_file'] is not None:  # noqa: E501
            query_params.append(('playback_file', local_var_params['playback_file']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/requests/{controller_id}/delete_audio_playback_file', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_request(self, request_id, **kwargs):  # noqa: E501
        """DELETE request  # noqa: E501

        Delete an existing request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_request(request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str request_id: the unique id of a request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_request_with_http_info(request_id, **kwargs)  # noqa: E501

    def delete_request_with_http_info(self, request_id, **kwargs):  # noqa: E501
        """DELETE request  # noqa: E501

        Delete an existing request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_request_with_http_info(request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str request_id: the unique id of a request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'request_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_request" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'request_id' is set
        if self.api_client.client_side_validation and ('request_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['request_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `request_id` when calling `delete_request`")  # noqa: E501

        if self.api_client.client_side_validation and 'request_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `request_id` when calling `delete_request`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'request_id' in local_var_params and local_var_params['request_id'] is not None:  # noqa: E501
            query_params.append(('request_id', local_var_params['request_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/requests', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_result_file(self, request_id, **kwargs):  # noqa: E501
        """DELETE result file  # noqa: E501

        Delete a test result file (recording file)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_result_file(request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str request_id: the unique id of the request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_result_file_with_http_info(request_id, **kwargs)  # noqa: E501

    def delete_result_file_with_http_info(self, request_id, **kwargs):  # noqa: E501
        """DELETE result file  # noqa: E501

        Delete a test result file (recording file)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_result_file_with_http_info(request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str request_id: the unique id of the request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'request_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_result_file" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'request_id' is set
        if self.api_client.client_side_validation and ('request_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['request_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `request_id` when calling `delete_result_file`")  # noqa: E501

        if self.api_client.client_side_validation and ('request_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['request_id']) > 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `request_id` when calling `delete_result_file`, length must be less than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and ('request_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['request_id']) < 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `request_id` when calling `delete_result_file`, length must be greater than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and 'request_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `request_id` when calling `delete_result_file`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'request_id' in local_var_params:
            path_params['request_id'] = local_var_params['request_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/requests/{request_id}/delete_result_file', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_result_files_in_range(self, controller_id, start_date, end_date, **kwargs):  # noqa: E501
        """DELETE result files in date-time range  # noqa: E501

        Delete result files in a date-time range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_result_files_in_range(controller_id, start_date, end_date, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param datetime start_date: start date (required)
        :param datetime end_date: end date (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_result_files_in_range_with_http_info(controller_id, start_date, end_date, **kwargs)  # noqa: E501

    def delete_result_files_in_range_with_http_info(self, controller_id, start_date, end_date, **kwargs):  # noqa: E501
        """DELETE result files in date-time range  # noqa: E501

        Delete result files in a date-time range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_result_files_in_range_with_http_info(controller_id, start_date, end_date, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param datetime start_date: start date (required)
        :param datetime end_date: end date (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'controller_id',
            'start_date',
            'end_date'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_result_files_in_range" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'controller_id' is set
        if self.api_client.client_side_validation and ('controller_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['controller_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `controller_id` when calling `delete_result_files_in_range`")  # noqa: E501
        # verify the required parameter 'start_date' is set
        if self.api_client.client_side_validation and ('start_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_date` when calling `delete_result_files_in_range`")  # noqa: E501
        # verify the required parameter 'end_date' is set
        if self.api_client.client_side_validation and ('end_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_date` when calling `delete_result_files_in_range`")  # noqa: E501

        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) > 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `delete_result_files_in_range`, length must be less than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) < 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `delete_result_files_in_range`, length must be greater than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and 'controller_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['controller_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `delete_result_files_in_range`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'controller_id' in local_var_params:
            path_params['controller_id'] = local_var_params['controller_id']  # noqa: E501

        query_params = []
        if 'start_date' in local_var_params and local_var_params['start_date'] is not None:  # noqa: E501
            query_params.append(('start_date', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params and local_var_params['end_date'] is not None:  # noqa: E501
            query_params.append(('end_date', local_var_params['end_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/requests/{controller_id}/delete_result_files_in_range', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_appium_device_screenshot_list(self, controller_id, **kwargs):  # noqa: E501
        """GET APPIUM device screenshot list  # noqa: E501

        Gets a list of all device screenshots  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_appium_device_screenshot_list(controller_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_appium_device_screenshot_list_with_http_info(controller_id, **kwargs)  # noqa: E501

    def get_appium_device_screenshot_list_with_http_info(self, controller_id, **kwargs):  # noqa: E501
        """GET APPIUM device screenshot list  # noqa: E501

        Gets a list of all device screenshots  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_appium_device_screenshot_list_with_http_info(controller_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse200, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'controller_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_appium_device_screenshot_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'controller_id' is set
        if self.api_client.client_side_validation and ('controller_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['controller_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `controller_id` when calling `get_appium_device_screenshot_list`")  # noqa: E501

        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) > 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `get_appium_device_screenshot_list`, length must be less than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) < 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `get_appium_device_screenshot_list`, length must be greater than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and 'controller_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['controller_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `get_appium_device_screenshot_list`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'controller_id' in local_var_params:
            path_params['controller_id'] = local_var_params['controller_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/requests/{controller_id}/APPIUM_get_screenshot_list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_appium_retrieve_device_screenshot(self, request_id, **kwargs):  # noqa: E501
        """GET APPIUM retrieve screenshot  # noqa: E501

        Retrieves the device screenshot  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_appium_retrieve_device_screenshot(request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str request_id: the unique id of the request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_appium_retrieve_device_screenshot_with_http_info(request_id, **kwargs)  # noqa: E501

    def get_appium_retrieve_device_screenshot_with_http_info(self, request_id, **kwargs):  # noqa: E501
        """GET APPIUM retrieve screenshot  # noqa: E501

        Retrieves the device screenshot  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_appium_retrieve_device_screenshot_with_http_info(request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str request_id: the unique id of the request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'request_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_appium_retrieve_device_screenshot" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'request_id' is set
        if self.api_client.client_side_validation and ('request_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['request_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `request_id` when calling `get_appium_retrieve_device_screenshot`")  # noqa: E501

        if self.api_client.client_side_validation and ('request_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['request_id']) > 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `request_id` when calling `get_appium_retrieve_device_screenshot`, length must be less than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and ('request_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['request_id']) < 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `request_id` when calling `get_appium_retrieve_device_screenshot`, length must be greater than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and 'request_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `request_id` when calling `get_appium_retrieve_device_screenshot`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'request_id' in local_var_params:
            path_params['request_id'] = local_var_params['request_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['image/png'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/requests/{request_id}/APPIUM_retrieve_screenshot', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_audio_playback_file_list(self, controller_id, **kwargs):  # noqa: E501
        """GET audio playback file list  # noqa: E501

        Get a list of all audio playback files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_audio_playback_file_list(controller_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_audio_playback_file_list_with_http_info(controller_id, **kwargs)  # noqa: E501

    def get_audio_playback_file_list_with_http_info(self, controller_id, **kwargs):  # noqa: E501
        """GET audio playback file list  # noqa: E501

        Get a list of all audio playback files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_audio_playback_file_list_with_http_info(controller_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse200, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'controller_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_audio_playback_file_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'controller_id' is set
        if self.api_client.client_side_validation and ('controller_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['controller_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `controller_id` when calling `get_audio_playback_file_list`")  # noqa: E501

        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) > 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `get_audio_playback_file_list`, length must be less than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) < 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `get_audio_playback_file_list`, length must be greater than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and 'controller_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['controller_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `get_audio_playback_file_list`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'controller_id' in local_var_params:
            path_params['controller_id'] = local_var_params['controller_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/requests/{controller_id}/get_audio_playback_file_list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_requests(self, **kwargs):  # noqa: E501
        """GET requests  # noqa: E501

        Get a list of requests  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_requests(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str device_id: the unique id of the device
        :param str request_id: the unique id of the request
        :param str status: the status of the request
        :param str controller_id: the unique id of the controller
        :param str action: the action requested
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[Request]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_requests_with_http_info(**kwargs)  # noqa: E501

    def get_requests_with_http_info(self, **kwargs):  # noqa: E501
        """GET requests  # noqa: E501

        Get a list of requests  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_requests_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str device_id: the unique id of the device
        :param str request_id: the unique id of the request
        :param str status: the status of the request
        :param str controller_id: the unique id of the controller
        :param str action: the action requested
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[Request], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'device_id',
            'request_id',
            'status',
            'controller_id',
            'action'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_requests" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and ('device_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['device_id']) > 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `device_id` when calling `get_requests`, length must be less than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and ('device_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['device_id']) < 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `device_id` when calling `get_requests`, length must be greater than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and 'device_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['device_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `device_id` when calling `get_requests`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        if self.api_client.client_side_validation and ('request_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['request_id']) > 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `request_id` when calling `get_requests`, length must be less than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and ('request_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['request_id']) < 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `request_id` when calling `get_requests`, length must be greater than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and 'request_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `request_id` when calling `get_requests`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        if self.api_client.client_side_validation and ('status' in local_var_params and  # noqa: E501
                                                        len(local_var_params['status']) > 32):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `status` when calling `get_requests`, length must be less than or equal to `32`")  # noqa: E501
        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) > 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `get_requests`, length must be less than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) < 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `get_requests`, length must be greater than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and 'controller_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['controller_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `get_requests`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        if self.api_client.client_side_validation and ('action' in local_var_params and  # noqa: E501
                                                        len(local_var_params['action']) > 32):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `action` when calling `get_requests`, length must be less than or equal to `32`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'device_id' in local_var_params and local_var_params['device_id'] is not None:  # noqa: E501
            query_params.append(('device_id', local_var_params['device_id']))  # noqa: E501
        if 'request_id' in local_var_params and local_var_params['request_id'] is not None:  # noqa: E501
            query_params.append(('request_id', local_var_params['request_id']))  # noqa: E501
        if 'status' in local_var_params and local_var_params['status'] is not None:  # noqa: E501
            query_params.append(('status', local_var_params['status']))  # noqa: E501
        if 'controller_id' in local_var_params and local_var_params['controller_id'] is not None:  # noqa: E501
            query_params.append(('controller_id', local_var_params['controller_id']))  # noqa: E501
        if 'action' in local_var_params and local_var_params['action'] is not None:  # noqa: E501
            query_params.append(('action', local_var_params['action']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/requests', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Request]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_retrieve_test_result_file(self, request_id, **kwargs):  # noqa: E501
        """GET test result file  # noqa: E501

        Retrieves the test result file (i.e. the recording of your call)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_retrieve_test_result_file(request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str request_id: the unique id of the request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_retrieve_test_result_file_with_http_info(request_id, **kwargs)  # noqa: E501

    def get_retrieve_test_result_file_with_http_info(self, request_id, **kwargs):  # noqa: E501
        """GET test result file  # noqa: E501

        Retrieves the test result file (i.e. the recording of your call)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_retrieve_test_result_file_with_http_info(request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str request_id: the unique id of the request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'request_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_retrieve_test_result_file" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'request_id' is set
        if self.api_client.client_side_validation and ('request_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['request_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `request_id` when calling `get_retrieve_test_result_file`")  # noqa: E501

        if self.api_client.client_side_validation and ('request_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['request_id']) > 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `request_id` when calling `get_retrieve_test_result_file`, length must be less than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and ('request_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['request_id']) < 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `request_id` when calling `get_retrieve_test_result_file`, length must be greater than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and 'request_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `request_id` when calling `get_retrieve_test_result_file`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'request_id' in local_var_params:
            path_params['request_id'] = local_var_params['request_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/requests/{request_id}/retrieve_result_file', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_test_result_file_list(self, controller_id, **kwargs):  # noqa: E501
        """GET test result file list  # noqa: E501

        Gets a list of all test result files (recordings)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_test_result_file_list(controller_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_test_result_file_list_with_http_info(controller_id, **kwargs)  # noqa: E501

    def get_test_result_file_list_with_http_info(self, controller_id, **kwargs):  # noqa: E501
        """GET test result file list  # noqa: E501

        Gets a list of all test result files (recordings)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_test_result_file_list_with_http_info(controller_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse200, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'controller_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_test_result_file_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'controller_id' is set
        if self.api_client.client_side_validation and ('controller_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['controller_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `controller_id` when calling `get_test_result_file_list`")  # noqa: E501

        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) > 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `get_test_result_file_list`, length must be less than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) < 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `get_test_result_file_list`, length must be greater than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and 'controller_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['controller_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `get_test_result_file_list`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'controller_id' in local_var_params:
            path_params['controller_id'] = local_var_params['controller_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/requests/{controller_id}/get_result_file_list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_request_heartbeat(self, request_id, **kwargs):  # noqa: E501
        """POST request heartbeat  # noqa: E501

        Request heartbeat  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_request_heartbeat(request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str request_id: the unique id of the request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_request_heartbeat_with_http_info(request_id, **kwargs)  # noqa: E501

    def post_request_heartbeat_with_http_info(self, request_id, **kwargs):  # noqa: E501
        """POST request heartbeat  # noqa: E501

        Request heartbeat  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_request_heartbeat_with_http_info(request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str request_id: the unique id of the request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'request_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_request_heartbeat" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'request_id' is set
        if self.api_client.client_side_validation and ('request_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['request_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `request_id` when calling `post_request_heartbeat`")  # noqa: E501

        if self.api_client.client_side_validation and ('request_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['request_id']) > 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `request_id` when calling `post_request_heartbeat`, length must be less than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and ('request_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['request_id']) < 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `request_id` when calling `post_request_heartbeat`, length must be greater than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and 'request_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `request_id` when calling `post_request_heartbeat`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'request_id' in local_var_params:
            path_params['request_id'] = local_var_params['request_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/requests/{request_id}/heartbeat', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_appium_install_ios_webdriveragent(self, controller_id, **kwargs):  # noqa: E501
        """PUT APPIUM install ios webdriveragent  # noqa: E501

        Sign and install iOS WebDriverAgent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_appium_install_ios_webdriveragent(controller_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_appium_install_ios_webdriveragent_with_http_info(controller_id, **kwargs)  # noqa: E501

    def put_appium_install_ios_webdriveragent_with_http_info(self, controller_id, **kwargs):  # noqa: E501
        """PUT APPIUM install ios webdriveragent  # noqa: E501

        Sign and install iOS WebDriverAgent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_appium_install_ios_webdriveragent_with_http_info(controller_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'controller_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_appium_install_ios_webdriveragent" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'controller_id' is set
        if self.api_client.client_side_validation and ('controller_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['controller_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `controller_id` when calling `put_appium_install_ios_webdriveragent`")  # noqa: E501

        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) > 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `put_appium_install_ios_webdriveragent`, length must be less than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) < 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `put_appium_install_ios_webdriveragent`, length must be greater than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and 'controller_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['controller_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `put_appium_install_ios_webdriveragent`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'controller_id' in local_var_params:
            path_params['controller_id'] = local_var_params['controller_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/requests/{controller_id}/APPIUM_install_ios_webdriveragent', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_appium_upload_ios_certificates(self, controller_id, certificates_zip_file, **kwargs):  # noqa: E501
        """PUT APPIUM upload ios certificates  # noqa: E501

        Upload ios certificates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_appium_upload_ios_certificates(controller_id, certificates_zip_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param file certificates_zip_file: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_appium_upload_ios_certificates_with_http_info(controller_id, certificates_zip_file, **kwargs)  # noqa: E501

    def put_appium_upload_ios_certificates_with_http_info(self, controller_id, certificates_zip_file, **kwargs):  # noqa: E501
        """PUT APPIUM upload ios certificates  # noqa: E501

        Upload ios certificates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_appium_upload_ios_certificates_with_http_info(controller_id, certificates_zip_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param file certificates_zip_file: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'controller_id',
            'certificates_zip_file'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_appium_upload_ios_certificates" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'controller_id' is set
        if self.api_client.client_side_validation and ('controller_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['controller_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `controller_id` when calling `put_appium_upload_ios_certificates`")  # noqa: E501
        # verify the required parameter 'certificates_zip_file' is set
        if self.api_client.client_side_validation and ('certificates_zip_file' not in local_var_params or  # noqa: E501
                                                        local_var_params['certificates_zip_file'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `certificates_zip_file` when calling `put_appium_upload_ios_certificates`")  # noqa: E501

        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) > 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `put_appium_upload_ios_certificates`, length must be less than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) < 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `put_appium_upload_ios_certificates`, length must be greater than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and 'controller_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['controller_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `put_appium_upload_ios_certificates`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'controller_id' in local_var_params:
            path_params['controller_id'] = local_var_params['controller_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'certificates_zip_file' in local_var_params:
            local_var_files['certificates_zip_file'] = local_var_params['certificates_zip_file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/requests/{controller_id}/APPIUM_upload_ios_certificates', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_request(self, **kwargs):  # noqa: E501
        """PUT request  # noqa: E501

        Add or update a request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_request(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Request request: the model of a request
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_request_with_http_info(**kwargs)  # noqa: E501

    def put_request_with_http_info(self, **kwargs):  # noqa: E501
        """PUT request  # noqa: E501

        Add or update a request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_request_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Request request: the model of a request
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_request" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request' in local_var_params:
            body_params = local_var_params['request']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/requests', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_request_status(self, request_id, status, **kwargs):  # noqa: E501
        """PUT request status  # noqa: E501

        Put request status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_request_status(request_id, status, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str request_id: the unique id of the request (required)
        :param str status: status (required)
        :param str message: message body
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_request_status_with_http_info(request_id, status, **kwargs)  # noqa: E501

    def put_request_status_with_http_info(self, request_id, status, **kwargs):  # noqa: E501
        """PUT request status  # noqa: E501

        Put request status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_request_status_with_http_info(request_id, status, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str request_id: the unique id of the request (required)
        :param str status: status (required)
        :param str message: message body
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'request_id',
            'status',
            'message'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_request_status" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'request_id' is set
        if self.api_client.client_side_validation and ('request_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['request_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `request_id` when calling `put_request_status`")  # noqa: E501
        # verify the required parameter 'status' is set
        if self.api_client.client_side_validation and ('status' not in local_var_params or  # noqa: E501
                                                        local_var_params['status'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `status` when calling `put_request_status`")  # noqa: E501

        if self.api_client.client_side_validation and ('request_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['request_id']) > 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `request_id` when calling `put_request_status`, length must be less than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and ('request_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['request_id']) < 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `request_id` when calling `put_request_status`, length must be greater than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and 'request_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `request_id` when calling `put_request_status`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'request_id' in local_var_params:
            path_params['request_id'] = local_var_params['request_id']  # noqa: E501

        query_params = []
        if 'status' in local_var_params and local_var_params['status'] is not None:  # noqa: E501
            query_params.append(('status', local_var_params['status']))  # noqa: E501
        if 'message' in local_var_params and local_var_params['message'] is not None:  # noqa: E501
            query_params.append(('message', local_var_params['message']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/requests/{request_id}/status', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_upload_audio_playback_file(self, controller_id, playback_file, **kwargs):  # noqa: E501
        """PUT upload audio playback file  # noqa: E501

        Upload audio playback file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_upload_audio_playback_file(controller_id, playback_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param file playback_file: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_upload_audio_playback_file_with_http_info(controller_id, playback_file, **kwargs)  # noqa: E501

    def put_upload_audio_playback_file_with_http_info(self, controller_id, playback_file, **kwargs):  # noqa: E501
        """PUT upload audio playback file  # noqa: E501

        Upload audio playback file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_upload_audio_playback_file_with_http_info(controller_id, playback_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str controller_id: the unique id of a controller (required)
        :param file playback_file: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'controller_id',
            'playback_file'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_upload_audio_playback_file" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'controller_id' is set
        if self.api_client.client_side_validation and ('controller_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['controller_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `controller_id` when calling `put_upload_audio_playback_file`")  # noqa: E501
        # verify the required parameter 'playback_file' is set
        if self.api_client.client_side_validation and ('playback_file' not in local_var_params or  # noqa: E501
                                                        local_var_params['playback_file'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `playback_file` when calling `put_upload_audio_playback_file`")  # noqa: E501

        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) > 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `put_upload_audio_playback_file`, length must be less than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and ('controller_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['controller_id']) < 36):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `put_upload_audio_playback_file`, length must be greater than or equal to `36`")  # noqa: E501
        if self.api_client.client_side_validation and 'controller_id' in local_var_params and not re.search(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', local_var_params['controller_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `controller_id` when calling `put_upload_audio_playback_file`, must conform to the pattern `/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'controller_id' in local_var_params:
            path_params['controller_id'] = local_var_params['controller_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'playback_file' in local_var_params:
            local_var_files['playback_file'] = local_var_params['playback_file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/requests/{controller_id}/upload_audio_playback_file', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
