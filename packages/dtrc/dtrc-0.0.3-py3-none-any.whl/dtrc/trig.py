# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_trig.ipynb.

# %% auto 0
__all__ = ['rotmat', 'rotate', 'ntheta', 'ctheta', 'catrad', 'rad2pnt', 'chord']

# %% ../nbs/10_trig.ipynb 6
from functools import singledispatch

# %% ../nbs/10_trig.ipynb 8
#| export

# %% ../nbs/10_trig.ipynb 11
#| export

# %% ../nbs/10_trig.ipynb 13
try: import numpy as np
except ImportError: ...

# %% ../nbs/10_trig.ipynb 15
#| export


# %% ../nbs/10_trig.ipynb 17
#| export


# %% ../nbs/10_trig.ipynb 19
from ltyp import dim1, real, nparray

# %% ../nbs/10_trig.ipynb 21
from .atyp import XYArray, RotationMatrix

# %% ../nbs/10_trig.ipynb 24
def rotmat(theta: real) -> RotationMatrix:
    return np.array([[np.cos(theta), -np.sin(theta)], 
                     [np.sin(theta),  np.cos(theta)]])

def rotate(m: XYArray, theta: real) -> XYArray:
    '''Rotate a matrix of 2D points by a given angle.'''
    return np.matmul(m, rotmat(theta).T)

# %% ../nbs/10_trig.ipynb 26
def ntheta(n: int) -> nparray:
    '''Get n equidistant angles (thetas) from the unit circle.'''
    return np.linspace(0, 2 * np.pi, n, endpoint=False)

def ctheta(n: int = 1) -> float:
    '''Categorical theta. Calculate the degree of rotation per category for a given number of categories.'''
    if n < 2: return 0
    return ntheta(n)[1] - ntheta(n)[0]

def catrad(i: int, n: int = 1) -> float:
    '''Categorical theta for category i of n categories.'''
    return ctheta(n) * i

# %% ../nbs/10_trig.ipynb 28
# Define a generic function with a single dispatch
@singledispatch
def rad2pnt(theta: real, sx: real = 1, sy: real = 1):
    '''Polar (radians) --> Cartesian (x, y) coordinates.'''
    raise NotImplementedError('Unsupported type')

# Register the function for handling np.ndarray
@rad2pnt.register(np.ndarray)
@rad2pnt.register(list)
@rad2pnt.register(tuple)
def _(theta: np.ndarray, sx: float = 1, sy: float = 1):
    coord = np.column_stack([sx * np.cos(theta), sy * np.sin(theta)])
    return coord

# Register the function for handling numeric types (float, int, num)
@rad2pnt.register(float)
@rad2pnt.register(int)
@rad2pnt.register(real)
def _(theta: float, sx: float = 1, sy: float = 1):
    return rad2pnt.dispatch(np.ndarray)(theta, sx, sy)[0]

# %% ../nbs/10_trig.ipynb 30
# Define a generic function with a single dispatch
@singledispatch
def chord(a: real, b: real, *args, sx: real = 1, sy: real = 1, **kwargs, ):
    '''Calculate the chord length between two angles.'''
    raise NotImplementedError('Unsupported type')

@chord.register(np.ndarray)
def _(thetas: np.ndarray, y: np.ndarray = None, *args, sx: real = 1, sy: real = 1, **kwargs):
    shape = np.asarray(thetas).shape        
    if isinstance(y, np.ndarray) and y.shape == shape: 
        return chord.dispatch(np.ndarray)(np.stack((thetas, y)), sx=sx, sy=sy)
    if len(shape) == 1 and shape[0] >= 2: return chord.dispatch(dim1)(thetas, sx=sx, sy=sy)
    if len(shape) >= 2 and shape[1] >= 2: x, y, *_ = thetas[:2]
    return np.linalg.norm(x - y) 
   
@chord.register(list)
def _(thetas: dim1, *args, sx: real = 1, sy: real = 1, **kwargs):
    return chord.dispatch(np.ndarray)(np.asarray(thetas), sx=sx, sy=sy)

@chord.register(dim1)
def _(thetas: dim1, *args, sx: real = 1, sy: real = 1, **kwargs):
    return chord.dispatch(np.ndarray)(rad2pnt(thetas, sx, sy)[:2], sx=sx, sy=sy)
   
@chord.register(float)
@chord.register(int)
@chord.register(real)
def _(x: real, y: real, *args, sx: real = 1, sy: real = 1, **kwargs):
    return chord.dispatch(np.ndarray)(rad2pnt([x, y], sx, sy), sx=sx, sy=sy)

# %% ../nbs/10_trig.ipynb 32
#| export
