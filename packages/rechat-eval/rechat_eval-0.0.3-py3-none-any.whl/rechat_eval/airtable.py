# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_airtable.ipynb.

# %% auto 0
__all__ = ['get_run_id', 'filter_rows', 'AirTableRecord', 'process_row', 'get_airtable_rows', 'get_status']

# %% ../nbs/01_airtable.ipynb 4
import os, re
from collections import Counter
from concurrent.futures import ThreadPoolExecutor
from typing import Union, List
from datetime import datetime, timezone, timedelta
import pandas as pd
from fastcore.foundation import L, AttrDict, getattrs
from pyairtable import Api
from pydantic import BaseModel
from langfree.transform import RunData
from langfree.chatrecord import ChatRecord, NoChatOpenAI
from tqdm import tqdm
from langsmith.utils import LangSmithError

# %% ../nbs/01_airtable.ipynb 7
def _is_older_than_n_days(record, n=2):
    created_time_str = record['createdTime'].replace("Z", "+00:00")  # Convert to a format recognized by fromisoformat
    created_time = datetime.fromisoformat(created_time_str)
    created_time = created_time.astimezone(timezone.utc)  # Make it timezone aware

    now = datetime.now(timezone.utc)
    time_difference = now - created_time

    return time_difference > timedelta(days=2)

def _get_pre(url):
    pattern = r'peek=([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})'
    match = re.search(pattern, url)
    if match: return match.group(1)

# %% ../nbs/01_airtable.ipynb 9
def _get_run(url):
    pattern = r'/r/([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})'
    match = re.search(pattern, url)
    if match: return match.group(1)

# %% ../nbs/01_airtable.ipynb 11
def get_run_id(row):
    "Parse the Run ID."
    if 'fields' not in row or 'Langsmith URL' not in row['fields']: return None
    url = row['fields']['Langsmith URL']
    if '/r/' in url: return url.split('/r/')[-1]
    elif 'peek=' in url: return _get_pre(url)
    else: 
        return None

def filter_rows(row, row_ids_keep=[]):
    "Get only airtable rows that are marked as 'Good' with a valid 'Scenario' and need to be reviewed."
    fields = row.get('fields')
    rid = get_run_id(row)
    if rid and fields and 'Review Status' in fields and 'Dataset' in fields and 'Langsmith URL' in fields:
        return fields['Dataset'] == 'Good' and fields['Review Status'] == 'Pending'
    else: return False

# %% ../nbs/01_airtable.ipynb 12
class AirTableRecord(BaseModel):
    airtable_id:Union[str, None] = None
    airtable_url:Union[str, None] = None
    langsmith_url:Union[str, None] = None
    langsmith_run_id:Union[str, None] = None
    review_status:Union[str, None] = None
    scenario:Union[str, None] = None
    tool:Union[str, None] = None
    author:Union[str, None] = None
    langsmith_run:RunData

# %% ../nbs/01_airtable.ipynb 13
def _get_rows(base_id:str='appRZa6i93tCsExsx', table_name:str='tblLefkPXK7nzRCC8', max_records=None):
    api = Api(os.environ['AIRTABLE_PAT'])
    table = api.table(base_id, table_name)
    return L(table.all(view='ðŸ”Ž Waiting For Review', max_records=max_records)).filter(filter_rows)

# %% ../nbs/01_airtable.ipynb 14
def process_row(row, base_id, table_name):
    err = None
    ls_run_id = get_run_id(row)
    rid = row['id']
    at_url = f"https://airtable.com/{base_id}/{table_name}/{rid}"
    fields = row['fields']
    ls_url = fields['Langsmith URL']
    if not ls_run_id: print(f'Not able to parse run id from {url} found at {at_url}')
    cr = None
    if ls_run_id:
        try: cr = ChatRecord.from_run_id(ls_run_id)
        except NoChatOpenAI as e: 
            print(f'No child `ChatOpenAI` found for {ls_run_id} from {ls_url} from this airtable record: {at_url}')
            return None
        except Exception as e: 
            print(f'failed to get {ls_run_id} from {ls_url} referenced in this airtable record: {at_url}\nOriginal Error Message:{e}\n\n')
            return None
        if not cr: return None
        else:
            return AirTableRecord(
                        airtable_id=rid,
                        airtable_url=at_url,
                        langsmith_url=ls_url,
                        langsmith_run_id=ls_run_id,
                        review_status=row['fields']['Review Status'],
                        chat_record=cr,
                        langsmith_run=cr.child_run,
                        scenario = str(fields.get('Scenario')),
                        tool = str(fields.get('Tool')),
                        author = str(fields.get('Author'))
                    )


def get_airtable_rows(base_id:str='appRZa6i93tCsExsx', table_name='tblLefkPXK7nzRCC8', max_records=None):
    atrows = []
    rows = _get_rows(base_id, table_name, max_records=max_records)

    with ThreadPoolExecutor() as executor:
        results = list(tqdm(executor.map(lambda row: process_row(row, base_id, table_name), rows), 
                            total=len(rows), 
                            desc='Processing rows', 
                            ncols=100,
                            mininterval=1))
    atrows = [result for result in results if result is not None]
    print(f'{len(atrows)} valid rows found')
    return atrows

# %% ../nbs/01_airtable.ipynb 16
def get_status(rows:List[AirTableRecord]):
    df = (pd.DataFrame(L(rows).map(lambda x: getattrs(x, 'tool', 'scenario','review_status') + [1]),
                         columns=['Tool', 'Scenario', 'Status', 'Count'])
            .pivot_table(index=['Tool', 'Scenario'], 
                        columns=['Status'],
                        aggfunc={'Count': "sum"}, 
                         fill_value=0))
    df.columns = df.columns.to_series().str[-1]
    return df.reset_index()
