import re
from pathlib import Path
from datetime import datetime

from loguru import logger
from httpx import AsyncClient, HTTPError
from pydantic import BaseModel, field_validator


class Image(BaseModel):
    """
    A single image object returned from Gemini.

    Parameters
    ----------
    url: `str`
        URL of the image
    title: `str`, optional
        Title of the image, by default is "[Image]"
    alt: `str`, optional
        Optional description of the image
    """

    url: str
    title: str = "[Image]"
    alt: str = ""

    def __str__(self):
        return f"{self.title}({self.url}) - {self.alt}"

    def __repr__(self):
        return f"""Image(title='{self.title}', url='{len(self.url) <= 20 and self.url or self.url[:8] + '...' + self.url[-12:]}', alt='{self.alt}')"""

    async def save(
        self,
        path: str = "temp",
        filename: str | None = None,
        cookies: dict | None = None,
        verbose: bool = False
    ) -> None:
        """
        Save the image to disk.

        Parameters
        ----------
        path: `str`, optional
            Path to save the image, by default will save to ./temp
        filename: `str`, optional
            Filename to save the image, by default will use the original filename from the URL
        cookies: `dict`, optional
            Cookies used for requesting the content of the image
        verbose : `bool`, optional
            If True, print the path of the saved file, by default False
        """
        try:
            filename = (
                filename
                or (
                    re.search(r"^(.*\.\w+)", self.url.split("/")[-1])
                    or re.search(r"^(.*)\?", self.url.split("/")[-1])
                ).group()
            )
        except AttributeError:
            filename = self.url.split("/")[-1]

        async with AsyncClient(follow_redirects=True, cookies=cookies) as client:
            response = await client.get(self.url)
            if response.status_code == 200:
                content_type = response.headers.get("content-type")
                if content_type and "image" not in content_type:
                    logger.warning(
                        f"Content type of {filename} is not image, but {content_type}."
                    )

                path = Path(path)
                path.mkdir(parents=True, exist_ok=True)

                dest = path / filename
                dest.write_bytes(response.content)

                if verbose:
                    logger.info(f"Image saved as {dest.resolve()}")
            else:
                raise HTTPError(
                    f"Error downloading image: {response.status_code} {response.reason_phrase}"
                )


class WebImage(Image):
    """
    Image retrieved from web. Returned when ask Gemini to "SEND an image of [something]".
    """

    pass


class GeneratedImage(Image):
    """
    Image generated by ImageFX, Google's AI image generator. Returned when ask Gemini to "GENERATE an image of [something]".

    Parameters
    ----------
    cookies: `dict`
        Cookies used for requesting the content of the generated image, inherit from GeminiClient object or manually set.
        Must contain valid "__Secure-1PSID" and "__Secure-1PSIDTS" values
    """

    cookies: dict[str, str]

    @field_validator("cookies")
    @classmethod
    def validate_cookies(cls, v: dict) -> dict:
        if "__Secure-1PSID" not in v or "__Secure-1PSIDTS" not in v:
            raise ValueError(
                "Cookies must contain '__Secure-1PSID' and '__Secure-1PSIDTS'"
            )
        return v

    # @override
    async def save(self, path: str = "temp/", filename: str = None) -> None:
        """
        Save the image to disk.

        Parameters
        ----------
        path: `str`
            Path to save the image
        filename: `str`, optional
            Filename to save the image, generated images are always in .png format, but file extension will not be included in the URL.
            And since the URL ends with a long hash, by default will use timestamp + end of the hash as the filename
        """
        await super().save(
            path,
            filename
            or f"{datetime.now().strftime('%Y%m%d%H%M%S')}_{self.url[-10:]}.png",
            self.cookies,
        )


class Candidate(BaseModel):
    """
    A single reply candidate object in the model output. A full response from Gemini usually contains multiple reply candidates.

    Parameters
    ----------
    rcid: `str`
        Reply candidate ID to build the metadata
    text: `str`
        Text output
    web_images: `list[WebImage]`, optional
        List of web images in reply, can be empty.
    generated_images: `list[GeneratedImage]`, optional
        List of generated images in reply, can be empty
    """

    rcid: str
    text: str
    web_images: list[WebImage] = []
    generated_images: list[GeneratedImage] = []

    def __str__(self):
        return self.text

    def __repr__(self):
        return f"Candidate(rcid='{self.rcid}', text='{len(self.text) <= 20 and self.text or self.text[:20] + '...'}', images={self.images})"

    @property
    def images(self) -> list[Image]:
        return self.web_images + self.generated_images


class ModelOutput(BaseModel):
    """
    Classified output from gemini.google.com

    Parameters
    ----------
    metadata: `list[str]`
        List of chat metadata `[cid, rid, rcid]`, can be shorter than 3 elements, like `[cid, rid]` or `[cid]` only
    candidates: `list[Candidate]`
        List of all candidates returned from gemini
    chosen: `int`, optional
        Index of the chosen candidate, by default will choose the first one
    """

    metadata: list[str]
    candidates: list[Candidate]
    chosen: int = 0

    def __str__(self):
        return self.text

    def __repr__(self):
        return f"ModelOutput(metadata={self.metadata}, chosen={self.chosen}, candidates={self.candidates})"

    @property
    def text(self) -> str:
        return self.candidates[self.chosen].text

    @property
    def images(self) -> list[Image]:
        return self.candidates[self.chosen].images

    @property
    def rcid(self) -> str:
        return self.candidates[self.chosen].rcid


class AuthError(Exception):
    """
    Exception for authentication errors caused by invalid credentials/cookies.
    """

    pass


class APIError(Exception):
    """
    Exception for package-level errors which need to be fixed in the future development (e.g. validation errors).
    """

    pass


class GeminiError(Exception):
    """
    Exception for errors returned from Gemini server which are not handled by the package.
    """

    pass


class TimeoutError(GeminiError):
    """
    Exception for request timeouts.
    """

    pass
