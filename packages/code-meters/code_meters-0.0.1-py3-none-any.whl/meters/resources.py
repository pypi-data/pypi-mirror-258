from dataclasses import dataclass
import functools
import resource
import time
from typing import Callable, Optional

from .printing import pretty_bytes, pretty_time


@dataclass
class ResourceUsage:
    cpu: float
    mem: int

    def __init__(self, cpu: Optional[float] = None, mem: Optional[int] = None):
        res = None
        if cpu is None or mem is None:
            res = resource.getrusage(resource.RUSAGE_SELF)
            if cpu is None:
                cpu = res.ru_utime
            if mem is None:
                mem = res.ru_maxrss * 1024
        self.cpu = cpu
        self.mem = mem

    def __str__(self):
        return (
            f"CPU time: {pretty_time(self.cpu)}, " + f"memory: {pretty_bytes(self.mem)}"
        )


@dataclass
class ResourceMeter:
    """Utility to measure resource usage

    Parameters
    ----------
    name: str, optional
        If set, it is added before the report (generated by `__str__` or printed
        by `__exit__`)

    Example
    -------
    ```python
    with ResourceMeter():
        do_something()
    ```
    """

    start: float
    elapsed: float
    start_cpu: float
    elapsed_cpu: float
    mem: int
    name: str = None

    def __init__(self, name: Optional[str] = None):
        self.start = time.perf_counter()
        self.elapsed = 0.0
        res = ResourceUsage()
        self.start_cpu = res.cpu
        self.elapsed_cpu = 0.0
        self.mem = res.mem
        self.name = name

    def update(self, reset: bool = False):
        t = time.perf_counter()
        res = ResourceUsage()
        if reset:
            self.start = t
            self.start_cpu = res.cpu
        self.elapsed = t - self.start
        self.elapsed_cpu = res.cpu - self.start_cpu
        self.mem = res.mem
        return self

    def __str__(self):
        return ("" if self.name is None else f"{self.name}: ") + ", ".join(
            [
                f"wall time: {pretty_time(self.elapsed)}",
                f"CPU time: {pretty_time(self.elapsed_cpu)}",
                f"memory: {pretty_bytes(self.mem)}",
            ]
        )

    def __enter__(self):
        self.update(reset=True)
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.update()
        print(str(self))


def metered(name_or_func=None, out=print, return_meter=False):
    """Automatically measure resource usage of a function

    To be used as a decorator

    Parameters
    ----------
    name_or_func: callable, str or None
        If str, use this instead of the function name when reporting
    out: callable, optional
        If set, call this function with the report as an `str` (default: `print`)
    return_meter: bool
        If True, the function returns a tuple where the first argument is the ResourceMeter
    """
    name = name_or_func if isinstance(name_or_func, str) else None

    def decorator(func: Callable) -> Callable:
        funcname = func.__name__ if name is None else name

        @functools.wraps(func)
        def wrapped(*args, **kwargs):
            meter = ResourceMeter(name=funcname)
            result = func(*args, **kwargs)
            meter.update()
            if out is not None:
                out(str(meter))
            if return_meter:
                return (meter, result)
            return result

        return wrapped

    if isinstance(name_or_func, str) or name_or_func is None:
        return decorator
    return decorator(name_or_func)
