"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const signaling_1 = require("@phosphor/signaling");
const core_1 = require("../core");
const setMethods_1 = require("../setMethods");
/**
 * The base parser class.
 *
 * A parser is something that generates widget definitions.
 * The pattern of use is as follows:
 *  - Instantiate the parser with a filename.
 *  - Connect consumers of widget definitions to the newWidget
 *    signal.
 *  - Call the start() method. Its promise will resolve once
 *    a signal has been emitted for all found widgets. Note
 *    that this does not entail that all consumers have finished
 *    processing *if they perform async processing*.
 */
class Parser {
    /**
     * Initialize the parser.
     *
     * @param input String input to the parser, typically a filename
     */
    constructor(input) {
        this.input = input;
        this._newWidget = new signaling_1.Signal(this);
    }
    /**
     * Find the names of all other *internal* widgets referenced by the
     * passed definition. Internal here means another widget that has/will
     * be parser by the parser. It should be valid to call before the
     * first time a newWidget signal is emitted.
     *
     * @param {IWidget} data The widget definition to inspect
     * @returns {MSet<string>} A set of widget names referenced
     */
    resolveInternalRefs(properties) {
        if (!properties) {
            return new setMethods_1.MSet();
        }
        let refs = new setMethods_1.MSet();
        for (let propName of Object.keys(properties)) {
            let prop = properties[propName];
            refs = refs.union(core_1.getWidgetRefs(prop));
        }
        return this.widgetNames.intersection(refs);
    }
    /**
     * Signal emitted by parser when it finds a new widget definition.
     *
     * @readonly
     * @type {ISignal<this, IWidget>}
     */
    get newWidget() {
        return this._newWidget;
    }
}
exports.Parser = Parser;
//# sourceMappingURL=base.js.map