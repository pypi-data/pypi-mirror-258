import { MSet } from './setMethods';
/**
 * A self-contained widget definition.
 */
export interface IWidget {
    properties?: {
        [key: string]: Attributes.Attribute;
    };
    name: string;
    inherits: string[];
    localDependencies: string[];
    help?: string;
}
export declare namespace Attributes {
    /**
     * Base structure for all attribute definitions.
     */
    interface IBase {
        type: string;
        help?: string;
        allowNull?: boolean;
    }
    /**
     * Array/sequence attribute definition.
     */
    interface IArray extends IBase {
        type: 'array';
        default?: any[] | null;
        items?: DefinedAttribute[] | DefinedAttribute;
    }
    /**
     * Widget reference attribute definition.
     */
    interface IWidgetRef extends IBase {
        type: 'widgetRef';
        widgetType: string | string[];
        default?: null;
    }
    /**
     * Object/hashmap/dictionary attribute definition.
     */
    interface IObject extends IBase {
        type: 'object';
        default?: any | null;
    }
    /**
     * String attribute definition.
     */
    interface IString extends IBase {
        type: 'string';
        default?: string | null;
    }
    /**
     * Floating point number attribute definition.
     */
    interface IFloat extends IBase {
        type: 'float';
        default?: number | null;
    }
    /**
     * Integer attribute definition.
     */
    interface IInteger extends IBase {
        type: 'int';
        default?: number | null;
    }
    /**
     * Boolean attribute definition.
     */
    interface IBoolean extends IBase {
        type: 'boolean';
        default?: boolean | null;
    }
    /**
     * Numpy.ndarray-like attribute definition.
     */
    interface INDArray extends IBase {
        type: 'ndarray';
        default?: any[] | null;
        shape?: number[];
        dtype: string;
    }
    /**
     * Dataunion attribute definition.
     *
     * See jupyter-datawidgets for details.
     */
    interface IDataUnion extends IBase {
        type: 'dataunion';
        default?: any[] | null;
        shape?: number[];
        dtype: string;
    }
    /**
     * Union attribute definition.
     */
    interface IUnion extends IBase {
        type: 'union';
        oneOf: DefinedAttribute[];
        default?: any | null;
    }
    /**
     * Any attribute definition.
     */
    interface IAny extends IBase {
        type: 'any';
        default?: any | null;
    }
    /**
     * An extended attribute definition.
     */
    type DefinedAttribute = (IArray | IObject | IWidgetRef | IString | IFloat | IInteger | IBoolean | IUnion | INDArray | IDataUnion | IAny);
    /**
     * An attribute definition.
     */
    type Attribute = DefinedAttribute | undefined;
    type Properties = {
        [key: string]: Attribute;
    };
    /**
     * Check whether the attribute defintion is for a union type.
     */
    function isUnion(data: Attribute): data is IUnion;
    /**
     * Check whether the attribute defintion is for a widget reference type.
     */
    function isWidgetRef(data: Attribute): data is IWidgetRef;
    /**
     * Check whether the attribute defintion is for an array/sequence type.
     */
    function isArray(data: Attribute): data is IArray;
    /**
     * Check whether the attribute defintion is for an ndarray type.
     */
    function isNDArray(data: Attribute): data is INDArray;
    /**
     * Check whether the attribute defintion is for an dataunion type.
     */
    function isDataUnion(data: Attribute): data is IDataUnion;
}
/**
 * Find all sub-definitions of an attribute defintion.
 *
 * @export
 * @param {AttributeDef} data The attribute definition
 * @returns {AttributeDef[]} A flattened array of all sub-definitions
 */
export declare function getSubDefinitions(data: Attributes.Attribute): Attributes.Attribute[];
/**
 * Whether an attribute definition contains a widget reference.
 *
 * Checks all sub-definitions for the presence of a widget reference.
 *
 * @export
 * @param {AttributeDef} data The attribute definition to check
 * @returns {boolean} Whether the attribute definition contains a widget reference
 */
export declare function hasWidgetRef(data: Attributes.Attribute): boolean;
/**
 * Get the names of any widget reference contained within an attribute definition.
 *
 * @export
 * @param {AttributeDef} data The atrtibute definition to check
 * @returns {MSet<string>} A set of the names of the referenced widgets.
 */
export declare function getWidgetRefs(data: Attributes.Attribute): MSet<string>;
