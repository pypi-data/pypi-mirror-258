"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const setMethods_1 = require("./setMethods");
var Attributes;
(function (Attributes) {
    /**
     * Check whether the attribute defintion is for a union type.
     */
    function isUnion(data) {
        return !!data && data.type === 'union';
    }
    Attributes.isUnion = isUnion;
    /**
     * Check whether the attribute defintion is for a widget reference type.
     */
    function isWidgetRef(data) {
        return !!data && data.type === 'widgetRef';
    }
    Attributes.isWidgetRef = isWidgetRef;
    /**
     * Check whether the attribute defintion is for an array/sequence type.
     */
    function isArray(data) {
        return !!data && data.type === 'array';
    }
    Attributes.isArray = isArray;
    /**
     * Check whether the attribute defintion is for an ndarray type.
     */
    function isNDArray(data) {
        return !!data && data.type === 'ndarray';
    }
    Attributes.isNDArray = isNDArray;
    /**
     * Check whether the attribute defintion is for an dataunion type.
     */
    function isDataUnion(data) {
        return !!data && data.type === 'dataunion';
    }
    Attributes.isDataUnion = isDataUnion;
})(Attributes = exports.Attributes || (exports.Attributes = {}));
/**
 * Find all sub-definitions of an attribute defintion.
 *
 * @export
 * @param {AttributeDef} data The attribute definition
 * @returns {AttributeDef[]} A flattened array of all sub-definitions
 */
function getSubDefinitions(data) {
    let directSubs;
    if (Attributes.isUnion(data)) {
        directSubs = data.oneOf;
    }
    else if (Attributes.isArray(data) && data.items) {
        directSubs = Array.isArray(data.items) ? data.items : [data.items];
    }
    else {
        return [];
    }
    return directSubs.reduce((cum, sub) => {
        return cum.concat(getSubDefinitions(sub));
    }, directSubs);
}
exports.getSubDefinitions = getSubDefinitions;
/**
 * Whether an attribute definition contains a widget reference.
 *
 * Checks all sub-definitions for the presence of a widget reference.
 *
 * @export
 * @param {AttributeDef} data The attribute definition to check
 * @returns {boolean} Whether the attribute definition contains a widget reference
 */
function hasWidgetRef(data) {
    if (Attributes.isWidgetRef(data)) {
        return true;
    }
    for (let sub of getSubDefinitions(data)) {
        if (Attributes.isWidgetRef(sub)) {
            return true;
        }
    }
    return false;
}
exports.hasWidgetRef = hasWidgetRef;
/**
 * Get the names of any widget reference contained within an attribute definition.
 *
 * @export
 * @param {AttributeDef} data The atrtibute definition to check
 * @returns {MSet<string>} A set of the names of the referenced widgets.
 */
function getWidgetRefs(data) {
    if (Attributes.isWidgetRef(data)) {
        return new setMethods_1.MSet(Array.isArray(data.widgetType) ? data.widgetType : [data.widgetType]);
    }
    return new setMethods_1.MSet(getSubDefinitions(data).reduce((cum, sub) => {
        if (Attributes.isWidgetRef(sub)) {
            return cum.concat(Array.isArray(sub.widgetType) ? sub.widgetType : [sub.widgetType]);
        }
        return cum;
    }, []));
}
exports.getWidgetRefs = getWidgetRefs;
//# sourceMappingURL=core.js.map