"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const nunjucks_1 = require("nunjucks");
const base_1 = require("./base");
const NUNJUCKS_ENV = nunjucks_1.configure(path.resolve(__dirname, '../../templates'), {
    autoescape: false,
    throwOnUndefined: true,
    trimBlocks: true,
    lstripBlocks: true,
});
/**
 * Base class for template based writers.
 *
 * Typical extension points when subclassing:
 * - Constructor: Pass in template and file extension for saving in options.
 * - transformState: Add any extra data needed to the state passed to the
 *   template engine.
 * - finalize: Add any finalization steps needed, e.g. writing an index file.
 *
 * @export
 * @class TemplateWriter
 * @extends {Writer}
 */
class TemplateWriter extends base_1.Writer {
    /**
     *
     */
    constructor(output, options) {
        super(output, options);
        /**
         * The envionment config for the template engine.
         *
         * @protected
         * @type {Environment}
         */
        this.env = NUNJUCKS_ENV;
        /**
         * If writing several files, this will contain the widget names
         * that define each module.
         */
        this._modules = [];
        /**
         * Internal working store of the widget state collected.
         */
        this._state = [];
        this.templateFile = options.template;
        this.fileExt = options.fileExt;
    }
    /**
     * Write out a sequence of widget definitions to disk.
     *
     * @param filename The filename to save to.
     * @param widgets The widget definitions to write.
     */
    write(filename, widgets) {
        const data = this.transformState({
            widgets: widgets.slice(),
        });
        if (!this.template) {
            throw new Error('Template not set!');
        }
        const output = this.template.render(data);
        fs.outputFileSync(filename, output);
    }
    /**
     * Hook that allows for modifying the state passed to the template engine.
     *
     * When overriding, take care not to modify the object in-place, as this
     * might affect the state of other writers. Instead create a copy with
     * the needed changes, and return that.
     *
     * @param data The current state that will be sent to the template engine.
     * @returns The modified state.
     */
    transformState(data) {
        return Object.assign({}, data, { modules: this._modules, outputMultiple: this.outputMultiple });
    }
    /**
     * The handler of widget data.
     *
     * Subclasses should normally not need to override this.
     *
     * @param {Parser} sender The parser producing the widget definition.
     * @param {IWidget} widget The widget definition
     */
    onWidget(sender, data) {
        let { name } = data;
        data = Object.assign({}, data);
        if (this.outputMultiple) {
            this._modules.push(name);
            this.write(this.filenameForWidget(data), [data]);
            return;
        }
        this._state.push(data);
    }
    /**
     * Called when the parser has finished processing all widgets.
     */
    finalize() {
        if (!this.outputMultiple) {
            return Promise.resolve().then(() => {
                return this.write(this.output, this._state);
            });
        }
        return Promise.resolve();
    }
    /**
     * If outputting multiple widgets, this function will
     * be called to determine the filename to use for a
     * given widget definition. The implementer is responsible
     * for taking `this.output` into account.
     *
     * @param widget The widget definition that will be saved
     */
    filenameForWidget(widget) {
        if (this.fileExt) {
            return path.join(this.output, `${widget.name}.${this.fileExt}`);
        }
        return path.join(this.output, widget.name);
    }
    /**
     * Get the compiled template to use to render the widget data.
     *
     * @readonly
     * @type {Template}
     */
    get template() {
        if (!this._template) {
            if (!this.templateFile) {
                throw new Error('No template file set!');
            }
            this._template = TemplateWriter.compileTemplate(this.templateFile, this.env);
        }
        return this._template;
    }
    get modules() {
        return this._modules;
    }
}
exports.TemplateWriter = TemplateWriter;
(function (TemplateWriter) {
    /**
     * Utility function for reading and compiling a template from file.
     *
     * @param templatePath The path to the template file.
     */
    function compileTemplate(templatePath, env) {
        return nunjucks_1.compile(fs.readFileSync(templatePath, {
            encoding: 'utf-8'
        }), env);
    }
    TemplateWriter.compileTemplate = compileTemplate;
})(TemplateWriter = exports.TemplateWriter || (exports.TemplateWriter = {}));
//# sourceMappingURL=template.js.map