"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const template_1 = require("./template");
const core_1 = require("../core");
const INDENT = '    ';
class PythonWriter extends template_1.TemplateWriter {
    /**
     *
     */
    constructor(output, options = {}) {
        super(output, Object.assign({ fileExt: 'py', template: path.resolve(__dirname, '../../templates/python.njk') }, options));
    }
    transformState(data) {
        data = super.transformState(data);
        data.widgets = data.widgets.map((widget) => {
            let { properties } = widget;
            return Object.assign({}, widget, { properties: properties ? Object.keys(properties).reduce((res, key) => {
                    let attr = properties[key];
                    res[key] = Object.assign({}, attr, { traitDef: makeTrait(attr) });
                    return res;
                }, {}) : properties });
        });
        return data;
    }
    finalize() {
        return super.finalize().then(() => {
            if (this.outputMultiple) {
                // Write init file for directory output
                let fname = path.join(this.output, `__init__.py`);
                let lines = this.modules.map((name) => {
                    return `from .${name} import ${name}`;
                });
                lines.push(''); // add an empty line at end
                return fs.writeFile(fname, lines.join('\n'));
            }
        });
    }
}
exports.PythonWriter = PythonWriter;
function convertValue(value) {
    if (value === true) {
        return 'True';
    }
    else if (value === false) {
        return 'False';
    }
    else if (value === null) {
        return 'None';
    }
    else if (value === undefined) {
        return '';
    }
    else if (Array.isArray(value)) {
        return `[${value.map(v => convertValue(v)).join(', ')}]`;
    }
    else if (typeof value === 'string') {
        return `'${value.toString()}'`;
    }
    return value.toString();
}
function makeTrait(data, innerTrait = false) {
    let traitDef;
    let tag = '.tag(sync=True)';
    if (data === undefined) {
        traitDef = 'Any(Undefined)';
    }
    else {
        // JSON object
        if (data.help) {
            tag = `.tag(sync=True, help='${data.help}')`;
        }
        let allowNoneArg = '';
        if (data.allowNull !== undefined && data.allowNull !== false) {
            allowNoneArg = `, allow_none=${convertValue(data.allowNull)}`;
        }
        let defValue = convertValue(data.default);
        if (core_1.Attributes.isUnion(data)) {
            const defs = data.oneOf.map((subdata) => makeTrait(subdata, true));
            traitDef = `Union([\n${INDENT}${INDENT}${defs.join(`,\n${INDENT}${INDENT}`)}\n${INDENT}], default_value=${defValue}${allowNoneArg})`;
        }
        else {
            switch (data.type) {
                case 'int':
                    traitDef = `Int(${defValue}${allowNoneArg})`;
                    break;
                case 'float':
                    traitDef = `Float(${defValue}${allowNoneArg})`;
                    break;
                case 'boolean':
                    traitDef = `Bool(${defValue}${allowNoneArg})`;
                    break;
                case 'string':
                    traitDef = `Unicode(${defValue}${allowNoneArg})`;
                    break;
                case 'object':
                    let defArg;
                    if (data.default === undefined) {
                        defArg = '';
                        // Remove ', ' from start of allowNoneArg
                        allowNoneArg = allowNoneArg.slice(2);
                    }
                    else {
                        defArg = `default_value=${defValue}`;
                    }
                    traitDef = `Dict(${defArg}${allowNoneArg})`;
                    break;
                case 'array':
                    let items = data.items;
                    if (items === undefined) {
                        traitDef = `Tuple(${defValue}${allowNoneArg})`;
                    }
                    else if (Array.isArray(items)) {
                        let lines = [];
                        for (let item of items) {
                            lines.push(makeTrait(item, true));
                        }
                        if (defValue) {
                            lines.push(`default_value=${defValue}`);
                        }
                        if (allowNoneArg) {
                            lines.push(allowNoneArg.slice(2));
                        }
                        traitDef = (`Tuple(\n` +
                            `${INDENT}${INDENT}${lines.join(`,\n${INDENT}${INDENT}`)}\n` +
                            `${INDENT})`);
                    }
                    else {
                        traitDef = `List(${makeTrait(items, true)}${defValue ? `, default_value=${defValue}` : ''}${allowNoneArg})`;
                    }
                    break;
                case 'widgetRef':
                    let type = data.widgetType;
                    if (Array.isArray(type)) {
                        const instances = type.map(function (typeName) {
                            return `${INDENT}${INDENT}Instance(${typeName})`;
                        });
                        traitDef = 'Union([\n' + instances.join(',\n') + `\n${INDENT}]${allowNoneArg})`;
                    }
                    else {
                        traitDef = `Instance(${type}${allowNoneArg})`;
                    }
                    break;
                case 'ndarray':
                    var { shape, dtype } = data;
                    let dtypeStr = '', shapeStr = '';
                    if (dtype) {
                        dtypeStr = `dtype=${dtype}`;
                    }
                    if (shape) {
                        let pyShape = shape.map((entry) => {
                            return entry === null ? 'None' : entry;
                        });
                        shapeStr = `.valid(shape_constraints(${pyShape.join(', ')}))`;
                    }
                    traitDef = `NDArray(${dtypeStr}${allowNoneArg})${shapeStr}`;
                    tag = tag.slice(0, tag.length - 1) + ', **array_serialization)';
                    break;
                case 'dataunion':
                    var { shape, dtype } = data;
                    let parts = [];
                    if (defValue !== '') {
                        parts.push(`${defValue}`);
                    }
                    if (dtype) {
                        parts.push(`dtype=${dtype}`);
                    }
                    if (shape) {
                        let pyShape = shape.map((entry) => {
                            return entry === null ? 'None' : entry;
                        });
                        parts.push(`shape_constraint=shape_constraints(${pyShape.join(', ')}))`);
                    }
                    traitDef = `DataUnion(${parts.join(', ')}${allowNoneArg})`;
                    tag = tag.slice(0, tag.length - 1) + ', **data_union_serialization)';
                    break;
                case 'any':
                    traitDef = `Any(${defValue}${allowNoneArg})`;
                    break;
                default:
                    throw new Error(`Unknown type: ${data.type}`);
            }
        }
    }
    if (innerTrait) {
        return traitDef;
    }
    else if (core_1.hasWidgetRef(data)) {
        tag = tag.slice(0, tag.length - 1) + ', **widget_serialization)';
    }
    return traitDef + tag;
}
//# sourceMappingURL=python.js.map